{"meta":{"title":"阿龙","subtitle":"全栈开发工程师","description":"","author":"阿龙","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2022-04-26T08:22:50.201Z","comments":true,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-04-26T08:17:55.000Z","updated":"2022-04-26T08:45:53.314Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2022-04-26T08:20:43.000Z","updated":"2022-04-26T08:20:50.927Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-04-26T08:21:14.000Z","updated":"2022-04-26T08:21:22.845Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-04-26T08:18:21.000Z","updated":"2022-04-26T08:20:24.203Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"contact","date":"2022-04-26T08:20:57.000Z","updated":"2022-04-26T08:21:03.666Z","comments":true,"path":"contact/index.html","permalink":"http://example.com/contact/index.html","excerpt":"","text":""}],"posts":[{"title":"webpack5_Loader","slug":"webpack5-Loader","date":"2022-04-21T06:47:27.000Z","updated":"2022-04-26T08:53:57.393Z","comments":true,"path":"2022/04/21/webpack5-Loader/","link":"","permalink":"http://example.com/2022/04/21/webpack5-Loader/","excerpt":"","text":"– webpack Loader整理1. Loader机制的作用是什么？ webpack 本身只能处理 JavaScript 和 JSON 文件，而 loader 为 webpack 添加了处理其他类型文件的能力。 webpack默认只能打包js文件，配置里的module.rules数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换打包成js。1注意：use属性的值需要是一个由 Loader 名称组成的数组，Loader 的执行顺序是由后到前的；每一个 Loader 都可以通过 URL querystring 的方式传入参数，例如css-loader?minimize中的minimize告诉css-loader要开启 CSS 压缩。 2. 有哪些常见的Loader？他们是解决什么问题的？123456789101112131415● file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件● url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去● source-map-loader：加载额外的 Source Map 文件，以方便断点调试● image-loader：加载并且压缩图片文件● babel-loader：把 ES6 转换成 ES5● css-loader：加载 CSS，支持模块化、压缩、文件导入等特性● style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。● eslint-loader：通过 ESLint 检查 JavaScript 代码 3. Webpack 的 Loader 是什么？Webpack 只能理解 JavaScript 和 JSON 文件，这是 Webpack 开箱可用的自带能力。loader 可以让 Webpack 能够去处理其他类型的文件，chunk 文件以供应用程序使用，以及被添加到依赖图中，也可将内联图像转换为 data URL。简单来说，loader 可以将一段代码转换成另一端代码，通常用来将一段特殊代码转换成一段浏览器可识别的代码。 loader 有两个属性： test，正则表达式，用于识别出哪些文件会被转换， use 定义在进行转换时应该使用哪个 loader，可以是字符串、数组和对象。","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[]},{"title":"webpack5_Plugin","slug":"webpack5-Plugin","date":"2022-04-21T01:18:03.000Z","updated":"2022-04-26T08:53:32.290Z","comments":true,"path":"2022/04/21/webpack5-Plugin/","link":"","permalink":"http://example.com/2022/04/21/webpack5-Plugin/","excerpt":"","text":"– webpack Plugin整理1. Plugin（插件）的作用是什么？通过安装和配置第三方的插件，可以拓展 webpack 的能力，从而让 webpack 用起来更方便。最常用的webpack 插件有如下两个： webpack-dev-server 类似于 node.js 阶段用到的 nodemon 工具每当修改了源代码，webpack 会自动进行项目的打包和构建 html-webpack-plugin webpack 中的 HTML 插件（类似于一个模板引擎插件）可以通过此插件自定制 index.html 页面的内容 webpack-dev-server 可以让 webpack 监听项目源代码的变化，从而进行自动打包构建。 12345修改package.json -&gt; scripts中的dev命令：&quot;scripts&quot;:&#123; &quot;dev&quot;：&quot;webpack serve&quot;，// script 节点下的脚本,可以通过 npm run 执行&#125; 2. 有哪些常见的Plugin？他们是解决什么问题的？12345678910111213141516● define-plugin：定义环境变量● commons-chunk-plugin：提取公共代码● uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码● purgecss-webpack-plugin：擦除无用css● happypack：多线程处理打包● webpack-bundle-analyzer：打包分析● speed-measure-webpack-plugin：构建速度分析● html-webpack-plugin：为html文件中引入的外部资源如script、link动态添加每次compile后的hash，防止引用缓存的外部文件问题 3. Webpack 的 Plugin 是什么？plugin是插件的意思，通常是用于对某个现有的架构进行扩展。 &#x3D;&#x3D;&gt; webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等。 4. Loader和Plugin的不同？不同的作用 Loader直译为”加载器”。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力 Plugin直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 不同的用法 Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options） Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。 4.描述一下编写loader或plugin的思路？12345Loader像一个&quot;翻译官&quot;把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。编写Loader时要遵循单一原则，每个Loader只做一种&quot;转义&quot;工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[]},{"title":"webpack整理","slug":"webpack5概念","date":"2022-04-20T05:44:06.000Z","updated":"2022-04-26T08:53:26.601Z","comments":true,"path":"2022/04/20/webpack5概念/","link":"","permalink":"http://example.com/2022/04/20/webpack5%E6%A6%82%E5%BF%B5/","excerpt":"","text":"– webpack5概念1.谈谈你对Webpack的理解？是一个模块化打包工具，将不同的资源和文件，进行打包，合并在一个文件里。 12341、依赖管理：方便引用第三方模块，让模块更容易复用、避免全局注入导致的冲突、、避免重复加载或者加载不必要的模块2、合并代码：把各个分散的模块集中打包成大文件，减少HTTP的链接的请求次数，配合uglify.js可以减少、优化代码的体积3、各种插件：babel把ES6+转[webpack5整理]()化为ES5-，eslint可以检查编译时的各种错误 2.webpack的工作原理?基本概念1234567891. Entry:入口指示webpack以哪个文件为入口起点开始打包，分析构建内部依赖图2. output:输出指示webpack的打包后的资源bundles输出到哪里去，以及如何命名3. Loader:让webpack能够去处理哪些非JavaScrip文件（webpack自身只理解javaScript)4. plugin:插件可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等5. mode:模式指示webpack使用相应模式的配置 流程概括12345678910111213141516webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：1. 初始化参数：从配置文件和Shell语句中读取与合并参数，得出最终的参数；2. 开始编译： 用上一步得到的参数初始化Complier对象，加载所有配置的插件，执行对象的run方法开始执行编译；3. 确定入口： 根据配置中的entry找出所有入口文件；4. 编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理；5. 完成模块编译： 在经过第4步使用Loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及他们之间的依赖关系；6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；7. 输出完成： 在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。在以上过程中，webpack会在特定的时间点广播出特定的时间，插件在监听到感兴趣的时间后会执行特定的逻辑，并且插件可以调用Webpack提供的API改变Webpack的运行结果。 流程细节 Webpack的构建流程可以分为以下三个阶段： 初始化：启动构建，读取与合并配置参数，加载Plugin，实例化Complier. 编译：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件内容，再找到该Module依赖的Module，递归地进行编译处理。 输出： 对编译后的Module组合成Chunk，把Chunk转换成文件，输出到文件系统。 3.webpack4和webpack5的区别？1234567891011121314151617181920212223242526272829303132333435更快的构建速度更高的版本要求更灵活的模块组合更智能的缓存优化更小的体积webpack4 上需要下载安装 terser-webpack-plugin 插件webpack5 内部本身就自带 js 压缩功能，他内置了 terser-webpack-plugin 插件，我们不用再下载安装。而且在 mode=“production” 的时候会自动开启 js 压缩功能。webpack4 缓存配置 ==&gt; npm install hard-source-webpack-plugin -D webpack5 缓存配置 ==&gt; webpack5 内部内置了 cache 缓存机制。直接配置即可。 ==&gt; cache 会在开发模式下被设置成 type： memory 而且会在生产模式把cache 给禁用掉。webpack4 启动服务 ==&gt; 通过 webpack-dev-server 启动服务 webpack5 启动服务 ==&gt; 内置使用 webpack serve 启动，但是他的日志不是很好，所以一般都加都喜欢用 webpack-dev-server 优化。打包的区别● webpack4打包:即使后续没有使用到num1的函数，依然会将代码打包进去● webpack5打包:后续没有使用到num1的函数，不会将代码打包进去输出代码的区别● webpack4只能输出es5的代码● webpack5新增属性output.ecmaVersion，可以生成ES5和ES6的代码 4. 前端代码为何要进行构建和打包？ 代码方面体积更小，加载更快（tree-shaking，压缩合并） 编译高级语言和语法（ts，es6，模块化） 兼容性和错误提示（polyfill，postcss，eslint） 研发流程统一、高效的开发环境 统一的构建流程和产出标准 集成公司构建规范（提测，上线） 5. webpack的优缺点？ 优点 webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD&#x2F;CMD 的支持也很全面，方便旧项目进行代码迁移。 能被模块化的不仅仅是 JS 了。 开发便捷，能替代部分 grunt&#x2F;gulp 的工作，比如打包、压缩混淆、图片转base64等。 扩展性强，插件机制完善 缺点 配置复杂 不分包bundle.js体积庞大 只能用于采用模块化开发的项目 打包慢 ES模块除Module外全用babel转换，但是一部分ES2015 语法的 firefox 与 chrome 浏览器中能直接跑的代码，无法用 webpack 编译 6. 什么是bundle，什么是chunk，什么是module12345bundle： 是由webpack打包出来的文件chunk： 是指webpack在进行模块依赖分析的时候，代码分割出来的代码块module： 是开发中的单个模块","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[]}],"categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[]}