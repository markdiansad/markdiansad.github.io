{"meta":{"title":"阿龙","subtitle":"全栈开发工程师","description":"","author":"阿龙","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2022-04-26T08:22:50.201Z","comments":true,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-04-26T08:21:14.000Z","updated":"2022-04-26T08:21:22.845Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-04-26T08:17:55.000Z","updated":"2022-04-26T08:45:53.314Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2022-04-26T08:20:43.000Z","updated":"2022-04-26T08:20:50.927Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2022-04-26T08:20:57.000Z","updated":"2022-04-26T08:21:03.666Z","comments":true,"path":"contact/index.html","permalink":"http://example.com/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-04-26T08:18:21.000Z","updated":"2022-04-26T08:20:24.203Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"webpack_优化","slug":"webpack-优化","date":"2022-04-22T12:45:36.000Z","updated":"2022-04-26T13:29:29.410Z","comments":true,"path":"2022/04/22/webpack-优化/","link":"","permalink":"http://example.com/2022/04/22/webpack-%E4%BC%98%E5%8C%96/","excerpt":"","text":"1、 如何提高webpack的构建速度？ 多入口情况下，使用CommonsChunkPlugin来提取公共代码 通过externals配置来提取常用库 利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。 使用Happypack 实现多线程加速编译 使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度 使用Tree-shaking和Scope Hoisting来剔除多余代码 2、 如何利用webpack来优化前端性能？（提高性能和体验）!用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。 压缩代码 删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css 利用CDN加速 在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径 删除死代码 将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数–optimize-minimize来实现 提取公共代码 异步组件 — 异步图片 — 配置webpack对小图片打包成base64字符 减少io请求 3、 怎么配置单页应用？怎么配置多页应用？ 单页应用 可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可 多页应用 可以使用webpack的 AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 4、 如何提升webpack的运行速度(开发环境) ,有哪些策略？ 多入口情况下，使用CommonsChunkPlugin来提取公共代码 通过externals配置来提取常用库 利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。 使用Happypack 实现多线程加速编译 使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度 使用Tree-shaking和Scope Hoisting来剔除多余代码 JS代码压缩 terser是一个JavaScript的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让bundle更小。在production模式下，webpack 默认就是使用 TerserPlugin 来处理我们的代码的。 TerserPlugin常用的属性如下： - extractComments：默认值为true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释 - parallel：使用多进程并发运行提高构建的速度，默认值是true，并发运行的默认数量： os.cpus().length - 1 - terserOptions：设置我们的terser相关的配置： compress：设置压缩相关的选项，mangle：设置丑化相关的选项，可以直接设置为true mangle：设置丑化相关的选项，可以直接设置为true toplevel：底层变量是否进行转换keep_classnames：保留类的名称 keep_fnames：保留函数的名称 代码压缩 cssCSS压缩通常用于去除无用的空格等，不过因为很难去修改选择器、属性的名称、值等，所以我们可以使用另外一个插件：css-minimizer-webpack-plugin Html文件代码压缩 文件大小压缩 对文件的大小进行压缩，可以有效减少http传输过程中宽带的损耗，文件压缩需要用到 compression-webpack-plugin插件 图片压缩 如果我们对bundle包进行分析，会发现图片等多媒体文件的大小是远远要比 js、css 文件要大的，所以图片压缩在打包方面也是很重要的 Tree Shaking Tree Shaking 是一个术语，在计算机中表示消除死代码，依赖于ES Module的静态语法分析。在webpack实现Trss shaking有两种不同的方案： usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的 sideEffects：跳过整个模块&#x2F;文件，直接查看该文件是否有副作用 usedExports的配置方法很简单，只需要将usedExports设为true即可，如下。而sideEffects则用于告知webpack compiler在编译时哪些模块有副作用，配置方法是在package.json中设置sideEffects属性。如果sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports，如果有些文件需要保留，可以设置为数组的形式。 代码分离 默认情况下，所有的JavaScript代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载， 就会影响首页的加载速度。如果可以分出出更小的bundle，以及控制资源加载优先级，从而优化加载性能。 代码分离可以通过splitChunksPlugin来实现，该插件webpack已经默认安装和集成，只需要配置即可。 splitChunks有如下几个属性： Chunks：对同步代码还是异步代码进行处理 minSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分 maxSize： 将大于maxSize的包，拆分为不小于minSize的包 minChunks：被引入的次数，默认是1 内联 chunk 可以通过InlineChunkHtmlPlugin插件将一些chunk的模块内联到html，如runtime的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大但是必须加载的，比如：总结一下，Webpack对前端性能的优化，主要是通过文件体积大小入手，主要的措施有分包、减少Http请求次数等。 5、 npm打包时需要注意哪些？如何利用webpack来更好的构建？Npm是目前最大的 JavaScript 模块仓库，里面有来自全世界开发者上传的可复用模块。你可能只是JS模块的使用者，但是有些情况你也会去选择上传自己开发的模块。关于NPM模块上传的方法可以去官网上进行学习，这里只讲解如何利用webpack来构建。 NPM模块需要注意以下问题：要支持CommonJS模块化规范，所以要求打包后的最后结果也遵守该规则。Npm模块使用者的环境是不确定的，很有可能并不支持ES6，所以打包的最后结果应该是采用ES5编写的。并且如果ES5是经过转换的，请最好连同SourceMap一同上传。Npm包大小应该是尽量小（有些仓库会限制包大小）发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。UI组件类的模块应该将依赖的其它资源文件，例如.css文件也需要包含在发布的模块里。 6、 什么是长缓存？在webpack中如何做到长缓存优化？ 浏览器在用户访问页面的时候，为了加快加载速度，会对用户访问的静态资源进行存储，但是每一次代码升级或者更新，都需要浏览器去下载新的代码，最方便和最简单的更新方式就是引入新的文件名称。 在webpack中，可以在output给出输出的文件制定chunkhash，并且分离经常更新的代码和框架代码，通过NameModulesPlugin或者HashedModulesPlugin使再次打包文件名不变。 7、 在项目中tree-shaking摇树不是很干净，有什么解决方案？ 在webpack.config.js中通过 来进行tree-shaking 但是单单指定这一个配置 不是很干净 有些模块导入，只要被引入， 就会对应用程序产生重要的影响。一个很好的例子就是全局样式表，或者设置全局配置的JavaScript 文件。 8、 怎么提高webpack的打包效率？ 开发环境优化 开启热模块替换（HMR） 使用 source-map 进行源代码映射 将只需要被loader执行一次的规则放到 oneOf 里面去 生产环境优化 对资源进行缓存 使用tree shaking（树摇） 使用code split 进行代码分割 文件懒加载和预加载 多进程打包 使用PWA（离线加载） 使用externals 忽略某些包，然后通过cdn引入 使用dll 技术对某些库（第三方库）进行单独打包 9、 按需加载的原理 使用符合ECMAScript 提案的import()语法 使用 webpack 特定的require.ensure 10、 预获取&#x2F;预加载模块Webpack v4.6.0+ 增加了对预获取和预加载的支持。 在声明 import 时，使用下面这些内置指令，可以让 webpack 输出 &quot;resource hint(资源提示)&quot;，来告知浏览器 ● prefetch(预获取)：将来某些导航下可能需要的资源 ● preload(预加载)：当前导航下可能需要资源 添加第二句魔法注释： webpackPrefetch: true 告诉 webpack 执行预获取。这会生成 &lt;link rel&#x3D;&quot;prefetch&quot; href&#x3D;&quot;math.js&quot;&gt; 并追加到页面头部，指示着浏览器在闲置时间预取 math.js 文件。 12. 什么是Tree-sharking? Tree是树，sharking是摇晃的意思。那么树摇晃的时候，肯定会’摇’下来一些无用的叶子。从编程的角度思考，如果假设我们的代码是一棵树（Tree），那么摇下来的无用的的叶子是什么呢？当然是无用的代码啦，他有个专业的术语，叫做dead-code（死码） 指打包中去除那些引入了但在代码中没用到的死代码。在wepack中js treeshaking通过UglifyJsPlugin来进行，css中通过purify-CSS来进行。","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[]},{"title":"webpack5_Loader","slug":"webpack-Loader","date":"2022-04-21T06:47:27.000Z","updated":"2022-04-26T13:49:40.647Z","comments":true,"path":"2022/04/21/webpack-Loader/","link":"","permalink":"http://example.com/2022/04/21/webpack-Loader/","excerpt":"","text":"webpack Loader整理1. Loader机制的作用是什么？ webpack 本身只能处理 JavaScript 和 JSON 文件，而 loader 为 webpack 添加了处理其他类型文件的能力。 webpack默认只能打包js文件，配置里的module.rules数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换打包成js。注意：use属性的值需要是一个由 Loader 名称组成的数组，Loader 的执行顺序是由后到前的； 每一个 Loader 都可以通过 URL querystring 的方式传入参数，例如css-loader?minimize 中的minimize告诉css-loader要开启 CSS 压缩。 2. 有哪些常见的Loader？他们是解决什么问题的？file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去 source-map-loader：加载额外的 Source Map 文件，以方便断点调试 image-loader：加载并且压缩图片文件 babel-loader：把 ES6 转换成 ES5 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。 eslint-loader：通过 ESLint 检查 JavaScript 代码 3. Webpack 的 Loader 是什么？Webpack 只能理解 JavaScript 和 JSON 文件，这是 Webpack 开箱可用的自带能力。loader 可以让 Webpack 能够去处理其他类型的文件，chunk 文件以供应用程序使用，以及被添加到依赖图中，也可将内联图像转换为 data URL。简单来说，loader 可以将一段代码转换成另一端代码，通常用来将一段特殊代码转换成一段浏览器可识别的代码。 loader 有两个属性： test，正则表达式，用于识别出哪些文件会被转换， use 定义在进行转换时应该使用哪个 loader，可以是字符串、数组和对象。","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[]},{"title":"webpack5_Plugin","slug":"webpack-Plugin","date":"2022-04-21T01:18:03.000Z","updated":"2022-04-26T14:05:31.611Z","comments":true,"path":"2022/04/21/webpack-Plugin/","link":"","permalink":"http://example.com/2022/04/21/webpack-Plugin/","excerpt":"","text":"– webpack Plugin整理1. Plugin（插件）的作用是什么？通过安装和配置第三方的插件，可以拓展 webpack 的能力，从而让 webpack 用起来更方便。最常用的webpack 插件有如下两个： webpack-dev-server 类似于 node.js 阶段用到的 nodemon 工具每当修改了源代码，webpack 会自动进行项目的打包和构建 html-webpack-plugin webpack 中的 HTML 插件（类似于一个模板引擎插件）可以通过此插件自定制 index.html 页面的内容 webpack-dev-server 可以让 webpack 监听项目源代码的变化，从而进行自动打包构建。 修改package.json -&gt; scripts中的dev命令： &quot;scripts&quot;:&#123; &quot;dev&quot;：&quot;webpack serve&quot;，&#x2F;&#x2F; script 节点下的脚本,可以通过 npm run 执行 &#125; 2. 有哪些常见的Plugin？他们是解决什么问题的？define-plugin：定义环境变量 commons-chunk-plugin：提取公共代码 uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码 purgecss-webpack-plugin：擦除无用css happypack：多线程处理打包 webpack-bundle-analyzer：打包分析 speed-measure-webpack-plugin：构建速度分析 html-webpack-plugin：为html文件中引入的外部资源如script、link动态添加每次compile后的hash，防止引用缓存的外部文件问题 3. Webpack 的 Plugin 是什么？plugin是插件的意思，通常是用于对某个现有的架构进行扩展。 &#x3D;&#x3D;&gt; webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等。 4. Loader和Plugin的不同？不同的作用 Loader直译为”加载器”。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力 Plugin直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 不同的用法 Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options） Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。 4.描述一下编写loader或plugin的思路？Loader像一个&quot;翻译官&quot;把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。 编写Loader时要遵循单一原则，每个Loader只做一种&quot;转义&quot;工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。 相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[]},{"title":"webpack整理","slug":"webpack概念","date":"2022-04-20T05:44:06.000Z","updated":"2022-04-26T08:53:26.601Z","comments":true,"path":"2022/04/20/webpack概念/","link":"","permalink":"http://example.com/2022/04/20/webpack%E6%A6%82%E5%BF%B5/","excerpt":"","text":"– webpack5概念1.谈谈你对Webpack的理解？是一个模块化打包工具，将不同的资源和文件，进行打包，合并在一个文件里。 1、依赖管理：方便引用第三方模块，让模块更容易复用、避免全局注入导致的冲突、、避免重复加载或者加载不必要的模块 2、合并代码：把各个分散的模块集中打包成大文件，减少HTTP的链接的请求次数，配合uglify.js可以减少、优化代码的体积 3、各种插件：babel把ES6+转[webpack5整理]()化为ES5-，eslint可以检查编译时的各种错误 2.webpack的工作原理?基本概念1. Entry:入口指示webpack以哪个文件为入口起点开始打包，分析构建内部依赖图 2. output:输出指示webpack的打包后的资源bundles输出到哪里去，以及如何命名 3. Loader:让webpack能够去处理哪些非JavaScrip文件（webpack自身只理解javaScript) 4. plugin:插件可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等 5. mode:模式指示webpack使用相应模式的配置 流程概括webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 1. 初始化参数：从配置文件和Shell语句中读取与合并参数，得出最终的参数； 2. 开始编译： 用上一步得到的参数初始化Complier对象，加载所有配置的插件，执行对象的run方法开始执行编译； 3. 确定入口： 根据配置中的entry找出所有入口文件； 4. 编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理； 5. 完成模块编译： 在经过第4步使用Loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及他们之间的依赖关系； 6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会； 7. 输出完成： 在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。 在以上过程中，webpack会在特定的时间点广播出特定的时间，插件在监听到感兴趣的时间后会执行特定的逻辑，并且插件可以调用Webpack提供的API改变Webpack的运行结果。 流程细节 Webpack的构建流程可以分为以下三个阶段： 初始化：启动构建，读取与合并配置参数，加载Plugin，实例化Complier. 编译：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件内容，再找到该Module依赖的Module，递归地进行编译处理。 输出： 对编译后的Module组合成Chunk，把Chunk转换成文件，输出到文件系统。 3.webpack4和webpack5的区别？更快的构建速度 更高的版本要求 更灵活的模块组合 更智能的缓存优化 更小的体积 webpack4 上需要下载安装 terser-webpack-plugin 插件 webpack5 内部本身就自带 js 压缩功能，他内置了 terser-webpack-plugin 插件，我们不用再下载安装。而且在 mode&#x3D;“production” 的时候会自动开启 js 压缩功能。 webpack4 缓存配置 &#x3D;&#x3D;&gt; npm install hard-source-webpack-plugin -D webpack5 缓存配置 &#x3D;&#x3D;&gt; webpack5 内部内置了 cache 缓存机制。直接配置即可。 &#x3D;&#x3D;&gt; cache 会在开发模式下被设置成 type： memory 而且会在生产模式把cache 给禁用掉。 webpack4 启动服务 &#x3D;&#x3D;&gt; 通过 webpack-dev-server 启动服务 webpack5 启动服务 &#x3D;&#x3D;&gt; 内置使用 webpack serve 启动，但是他的日志不是很好，所以一般都加都喜欢用 webpack-dev-server 优化。 打包的区别 ● webpack4打包:即使后续没有使用到num1的函数，依然会将代码打包进去 ● webpack5打包:后续没有使用到num1的函数，不会将代码打包进去 输出代码的区别 ● webpack4只能输出es5的代码 ● webpack5新增属性output.ecmaVersion，可以生成ES5和ES6的代码 4. 前端代码为何要进行构建和打包？ 代码方面体积更小，加载更快（tree-shaking，压缩合并） 编译高级语言和语法（ts，es6，模块化） 兼容性和错误提示（polyfill，postcss，eslint） 研发流程统一、高效的开发环境 统一的构建流程和产出标准 集成公司构建规范（提测，上线） 5. webpack的优缺点？ 优点 webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD&#x2F;CMD 的支持也很全面，方便旧项目进行代码迁移。 能被模块化的不仅仅是 JS 了。 开发便捷，能替代部分 grunt&#x2F;gulp 的工作，比如打包、压缩混淆、图片转base64等。 扩展性强，插件机制完善 缺点 配置复杂 不分包bundle.js体积庞大 只能用于采用模块化开发的项目 打包慢 ES模块除Module外全用babel转换，但是一部分ES2015 语法的 firefox 与 chrome 浏览器中能直接跑的代码，无法用 webpack 编译 6. 什么是bundle，什么是chunk，什么是modulebundle： 是由webpack打包出来的文件 chunk： 是指webpack在进行模块依赖分析的时候，代码分割出来的代码块 module： 是开发中的单个模块","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[]},{"title":"深拷贝和浅拷贝","slug":"深拷贝和浅拷贝","date":"2022-03-21T05:12:39.000Z","updated":"2022-04-27T01:24:23.653Z","comments":true,"path":"2022/03/21/深拷贝和浅拷贝/","link":"","permalink":"http://example.com/2022/03/21/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"深拷贝和浅拷贝浅拷贝和深拷贝都只针对于引用数据类型 浅拷贝 只复制指向对象的指针,而不复制对象本身，新旧对象还是共享同一块内存; 深拷贝 另外创造一个一模一样的对象,新对象跟原对象不共享内存,修改新对象不会影响到原对象 浅拷贝实现方法1.Object.assign方法 var obj &#x3D; &#123; a:1, b:2 &#125; var obj1 &#x3D; Object.assign(&#123;&#125;,obj) obj1.a &#x3D; 3: console.log(obj.a) &#x2F;&#x2F; 3 2.解构赋值 var obj1 &#x3D; &#123;a: 1, b: 2&#125; var obj2 &#x3D; &#123;...obj1&#125; obj2.a &#x3D; 4 console.log(obj1, obj2) 深拷贝实现方法1.json.stringify()方法 var obj1 &#x3D; [&#123; name: &#39;臧三&#39;, childs: [&#39;小明&#39;, &#39;小芳&#39;] &#125;] var obj2 &#x3D; JSON.parse(JSON.stringify(obj1)) obj2[0].childs &#x3D; [] console.log(obj1, obj2) 2.递归方法 var obj1 &#x3D; [&#123; name: &#39;臧三&#39;, childs: [&#39;小明&#39;, &#39;小芳&#39;], fn: function() &#123;&#125;, age: undefined &#125;] var obj2 &#x3D; extend(obj1) obj2[0].childs &#x3D; [] console.log(obj1, obj2) function extend(data) &#123; if (typeof data &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; data) &#123; let val &#x3D; typeof data.length &#x3D;&#x3D;&#x3D; &#39;number&#39; ? [] : &#123;&#125; for(let i in data) &#123; val[i] &#x3D; extend(data[i]) &#125; return val &#125; else &#123; return data &#125; &#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[]},{"title":"闭包的理解","slug":"闭包的理解","date":"2022-03-14T00:40:47.000Z","updated":"2022-04-27T01:10:12.654Z","comments":true,"path":"2022/03/14/闭包的理解/","link":"","permalink":"http://example.com/2022/03/14/%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"– 闭包的理解一个函数和对其他周围状态的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包。闭包可以在一个内层函数中访问到外层函数的作用域。 闭包的特点 可以让外部访问函数内部的变量。 可以避免使用全局变量。防止全局变量污染。 可以让局部变量常驻在内存中 会造成内存泄露(有一个内存空间长期被占用，而不被释放) 闭包示例 function fn1()&#123; var max &#x3D; 10; return function (x) &#123; if(x &gt; max)&#123; console.log(x); &#125; &#125; &#125; var fn2 &#x3D; fn1(); fn2(20);","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[]},{"title":"防抖与节流","slug":"防抖与节流","date":"2022-02-27T06:24:41.000Z","updated":"2022-04-27T01:29:28.298Z","comments":true,"path":"2022/02/27/防抖与节流/","link":"","permalink":"http://example.com/2022/02/27/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/","excerpt":"","text":"防抖与节流防抖在事件被触发的n秒后再执行回调,如果这n秒又被触发，则重新计时.高频操作下，只执行最后一次. &lt;script&gt; &#x2F;&#x2F; 防抖 用户触发事件过于频繁 let inp &#x3D; document.getElementsByTagName(&#39;input&#39;) inp[0].oninput &#x3D; deco(function () &#123; console.log(this.value) &#125;, 500) function deco(fn, time) &#123; let t &#x3D; null; return function () &#123; if (t) &#123; clearTimeout(t) &#125; t &#x3D; setTimeout(() &#x3D;&gt; &#123; fn.call(this) &#125;, time) &#125; &#125; &lt;&#x2F;script&gt; 节流一定时间内 控制触发的次数 &lt;script&gt; window.onscroll &#x3D; fn(function () &#123; console.log(1111111) &#125;, 500) function fn(fn1, time) &#123; let flag &#x3D; true; return function () &#123; if (flag) &#123; setTimeout(() &#x3D;&gt; &#123; fn1.call(this) flag &#x3D; true &#125;, time) &#125; flag &#x3D; false; &#125; &#125; &lt;&#x2F;script&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[]}],"categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[]}