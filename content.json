{"meta":{"title":"阿龙","subtitle":"全栈开发工程师","description":"","author":"阿龙","url":"http://example.com","root":"/"},"pages":[{"title":"tags","date":"2022-04-26T08:18:21.000Z","updated":"2022-04-26T08:20:24.203Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2022-04-26T08:20:43.000Z","updated":"2022-04-26T08:20:50.927Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2022-04-26T08:22:50.201Z","comments":true,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-04-26T08:17:55.000Z","updated":"2022-04-26T08:45:53.314Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-04-26T08:21:14.000Z","updated":"2022-04-26T08:21:22.845Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"contact","date":"2022-04-26T08:20:57.000Z","updated":"2022-04-26T08:21:03.666Z","comments":true,"path":"contact/index.html","permalink":"http://example.com/contact/index.html","excerpt":"","text":""}],"posts":[{"title":"connect组件原理分析","slug":"React/connect组件原理分析","date":"2022-12-12T07:23:44.000Z","updated":"2022-05-13T11:32:40.156Z","comments":true,"path":"2022/12/12/React/connect组件原理分析/","link":"","permalink":"http://example.com/2022/12/12/React/connect%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","excerpt":"","text":"connect用法作用：连接React组件与 Redux store connect([mapStateToProps], [mapDispatchToProps], [mergeProps],[options]) &#x2F;&#x2F; 这个函数允许我们将 store 中的数据作为 props 绑定到组件上 const mapStateToProps &#x3D; (state) &#x3D;&gt; &#123; return &#123; count: state.count &#125; &#125; 这个函数的第一个参数就是 Redux 的 store，我们从中摘取了 count 属性。你不必将 state 中的数据原封不动地传入组件，可以根据 state 中的数据，动态地输出组件需要的（最小）属性 函数的第二个参数 ownProps，是组件自己的 props 当 state 变化，或者 ownProps 变化的时候，mapStateToProps 都会被调用，计算出一个新的 stateProps，（在与 ownProps merge 后）更新给组件 mapDispatchToProps(dispatch, ownProps): dispatchProps connect 的第二个参数是 mapDispatchToProps，它的功能是，将 action 作为 props绑定到组件上，也会成为 MyComp 的 &#96;props 原理解析 首先connect之所以会成功，是因为Provider组件 在原应用组件上包裹一层，使原来整个应用成为Provider的子组件 接收Redux的store作为props，通过context对象传递给子孙组件上的connect connect做了些什么 它真正连接 Redux 和 React，它包在我们的容器组件的外一层，它接收上面 Provider提供的 store 里面的 state和 dispatch，传给一个构造函数，返回一个对象，以属性形式传给我们的容器组件 源码connect是一个高阶函数，首先传入mapStateToProps、mapDispatchToProps，然后返回一个生产Component的函数(wrapWithConnect)， 然后再将真正的Component作为参数传入wrapWithConnect，这样就生产出一个经过包裹的Connect组件，该组件具有如下特点 通过props.store获取祖先Component的store props包括stateProps、dispatchProps、parentProps,合并在一起得到nextState，作为props传给真正的Component componentDidMount时，添加事件this.store.subscribe(this.handleChange)，实现页面交互 shouldComponentUpdate时判断是否有避免进行渲染，提升页面性能，并得到nextState componentWillUnmount时移除注册的事件this.handleChange &#x2F;&#x2F; 主要逻辑 export default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options &#x3D; &#123;&#125;) &#123; return function wrapWithConnect(WrappedComponent) &#123; class Connect extends Component &#123; constructor(props, context) &#123; &#x2F;&#x2F; 从祖先Component处获得store this.store &#x3D; props.store || context.store this.stateProps &#x3D; computeStateProps(this.store, props) this.dispatchProps &#x3D; computeDispatchProps(this.store, props) this.state &#x3D; &#123; storeState: null &#125; &#x2F;&#x2F; 对stateProps、dispatchProps、parentProps进行合并 this.updateState() &#125; shouldComponentUpdate(nextProps, nextState) &#123; &#x2F;&#x2F; 进行判断，当数据发生改变时，Component重新渲染 if (propsChanged || mapStateProducedChange || dispatchPropsChanged) &#123; this.updateState(nextProps) return true &#125; &#125; componentDidMount() &#123; &#x2F;&#x2F; 改变Component的state this.store.subscribe(() &#x3D; &#123; this.setState(&#123; storeState: this.store.getState() &#125;) &#125;) &#125; render() &#123; &#x2F;&#x2F; 生成包裹组件Connect return ( &lt;WrappedComponent &#123;...this.nextState&#125; &#x2F;&gt; ) &#125; &#125; Connect.contextTypes &#x3D; &#123; store: storeShape &#125; return Connect; &#125; &#125;","categories":[{"name":"React","slug":"React","permalink":"http://example.com/categories/React/"}],"tags":[]},{"title":"React-17-带来了哪些改变","slug":"React/React-17-带来了哪些改变","date":"2022-12-01T06:23:44.000Z","updated":"2022-05-13T11:28:12.691Z","comments":true,"path":"2022/12/01/React/React-17-带来了哪些改变/","link":"","permalink":"http://example.com/2022/12/01/React/React-17-%E5%B8%A6%E6%9D%A5%E4%BA%86%E5%93%AA%E4%BA%9B%E6%94%B9%E5%8F%98/","excerpt":"","text":"最重要的是以下三点： 新的 JSX 转换逻辑 事件系统重构 Lane 模型的引入 ** 重构 JSX 转换逻辑**在过去，如果我们在 React 项目中写入下面这样的代码：function MyComponent() &#123; return &lt;p&gt;这是我的组件&lt;&#x2F;p&gt; &#125; React 是会报错的，原因是 React 中对 JSX 代码的转换依赖的是 React.createElement 这个函数。因此但凡我们在代码中包含了 JSX，那么就必须在文件中引入 React，像下面这样： import React from &#39;react&#39;; function MyComponent() &#123; return &lt;p&gt;这是我的组件&lt;&#x2F;p&gt; &#125; 而 React 17 则允许我们在不引入 React 的情况下直接使用 JSX。这是因为在 React 17 中，编译器会自动帮我们引入 JSX 的解析器，也就是说像下面这样一段逻辑： function MyComponent() &#123; return &lt;p&gt;这是我的组件&lt;&#x2F;p&gt; &#125; 会被编译器转换成这个样子： import &#123;jsx as _jsx&#125; from &#39;react&#x2F;jsx-runtime&#39;; function MyComponent() &#123; return _jsx(&#39;p&#39;, &#123; children: &#39;这是我的组件&#39; &#125;); &#125; react&#x2F;jsx-runtime 中的 JSX 解析器将取代 React.createElement 完成 JSX 的编译工作，这个过程对开发者而言是自动化、无感知的。因此，新的 JSX 转换逻辑带来的最显著的改变就是降低了开发者的学习成本。 react&#x2F;jsx-runtime 中的 JSX 解析器看上去似乎在调用姿势上和 React.createElement 区别不大，那么它是否只是 React.createElement 换了个马甲呢？当然不是，它在内部实现了 React.createElement 无法做到的性能优化和简化。在一定情况下，它可能会略微改善编译输出内容的大小 事件系统重构事件系统在 React 17 中的重构要从以下两个方面来看： 卸掉历史包袱 拥抱新的潮流 卸掉历史包袱：放弃利用 document 来做事件的中心化管控 React 16.13.x 版本中的事件系统会通过将所有事件冒泡到 document 来实现对事件的中心化管控 样的做法虽然看上去已经足够巧妙，但仍然有它不聪明的地方——document 是整个文档树的根节点，操作 document 带来的影响范围实在是太大了，这将会使事情变得更加不可控 在 React 17 中，React 团队终于正面解决了这个问题：事件的中心化管控不会再全部依赖 document，管控相关的逻辑被转移到了每个 React 组件自己的容器 DOM 节点中。比如说我们在 ID 为 root 的 DOM 节点下挂载了一个 React 组件，像下面代码这样： const rootElement &#x3D; document.getElementById(&quot;root&quot;); ReactDOM.render(&lt;App &#x2F;&gt;, rootElement); 那么事件管控相关的逻辑就会被安装到 root 节点上去。这样一来， React 组件就能够自己玩自己的，再也无法对全局的事件流构成威胁了 拥抱新的潮流：放弃事件池在 React 17 之前，合成事件对象会被放进一个叫作“事件池”的地方统一管理。这样做的目的是能够实现事件对象的复用，进而提高性能：每当事件处理函数执行完毕后，其对应的合成事件对象内部的所有属性都会被置空，意在为下一次被复用做准备。这也就意味着事件逻辑一旦执行完毕，我们就拿不到事件对象了，React 官方给出的这个例子就很能说明问题，请看下面这个代码 function handleChange(e) &#123; &#x2F;&#x2F; This won&#39;t work because the event object gets reused. setTimeout(() &#x3D;&gt; &#123; console.log(e.target.value); &#x2F;&#x2F; Too late! &#125;, 100); }异步执行的 setTimeout 回调会在 handleChange 这个事件处理函数执行完毕后执行，因此它拿不到想要的那个事件对象 e。 要想拿到目标事件对象，必须显式地告诉 React——我永远需要它，也就是调用 e.persist() 函数，像下面这样： function handleChange(e) &#123; &#x2F;&#x2F; Prevents React from resetting its properties: e.persist(); setTimeout(() &#x3D;&gt; &#123; console.log(e.target.value); &#x2F;&#x2F; Works &#125;, 100); &#125; 在 React 17 中，我们不需要 e.persist()，也可以随时随地访问我们想要的事件对象。 Lane 模型的引入 初学 React 源码的同学由此可能会很自然地认为：优先级就应该是用 Lane 来处理的。但事实上，React 16 中处理优先级采用的是 expirationTime 模型。 expirationTime 模型使用 expirationTime（一个时间长度） 来描述任务的优先级；而 Lane 模型则使用二进制数来表示任务的优先级： lane 模型通过将不同优先级赋值给一个位，通过 31 位的位运算来操作优先级。 Lane 模型提供了一个新的优先级排序的思路，相对于 expirationTime 来说，它对优先级的处理会更细腻，能够覆盖更多的边界条件。","categories":[{"name":"React","slug":"React","permalink":"http://example.com/categories/React/"}],"tags":[]},{"title":"什么是高阶组件","slug":"React/什么是高阶组件","date":"2022-06-01T07:56:47.000Z","updated":"2022-05-03T02:00:59.167Z","comments":true,"path":"2022/06/01/React/什么是高阶组件/","link":"","permalink":"http://example.com/2022/06/01/React/%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/","excerpt":"","text":"什么是高阶组件？高阶组件就是一个函数，该函数接受一个组件作为参数，并返回一个新的组件基本上，这是从React的组成性质派生的一种模式，我们称他们为”纯”组件，因为他们可以去接受任何动态提供的子组件，但他们不会修改或复制其输入组件的任何行为 高阶组件（HOC）是React用于复用组件逻辑的一种高级技巧 高阶组件的参数为一个组件返回一个新组件 组件将props转化为UI，而高阶组件时将组件转化为另一个组件","categories":[{"name":"React","slug":"React","permalink":"http://example.com/categories/React/"}],"tags":[]},{"title":"浏览器存储","slug":"浏览器/浏览器存储","date":"2022-05-05T01:48:26.000Z","updated":"2022-05-05T02:00:17.994Z","comments":true,"path":"2022/05/05/浏览器/浏览器存储/","link":"","permalink":"http://example.com/2022/05/05/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/","excerpt":"","text":"我们经常需要对业务中的一些数据进行存储，通常可以分为 短暂性存储 和 持久性储存。 短暂性的时候，我们只需要将数据存在内存中，只在运行时可用 持久性存储，可以分为 浏览器端 与 服务器端 浏览器 cookie: 通常用于存储用户身份，登录状态等 http 中自动携带， 体积上限为 4K， 可自行设置过期时间 localStorage &#x2F; sessionStorage: 长久储存&#x2F;窗口关闭删除， 体积限制为 4~5M indexDB 服务器 分布式缓存 redis 数据库 cookie和localStorage、session、indexDB 的区别 特性 cookie localStorage sessionStorage indexDB 数据生命周期 一般由服务器生成，可以设置过期时间 除非被清理，否则一直存在 页面关闭就清理 除非被清理，否则一直存在 数据存储大小 4K 5M 5M 无限 与服务端通信 每次都会携带在 header 中，对于请求性能影响 不参与 不参与 不参与 对于 cookie，我们还需要注意安全性 属性 作用 value 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 http-only 不能通过 JS访问 Cookie，减少 XSS攻击 secure 只能在协议为 HTTPS 的请求中携带 same-site 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[]},{"title":"浏览器缓存机制","slug":"浏览器/浏览器缓存机制","date":"2022-05-05T01:35:08.000Z","updated":"2022-05-05T01:48:03.838Z","comments":true,"path":"2022/05/05/浏览器/浏览器缓存机制/","link":"","permalink":"http://example.com/2022/05/05/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","excerpt":"","text":"缓存机制 首先得明确 http 缓存的好处减少了冗余的数据传输，减少网费减少服务器端的压力Web 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间加快客户端加载网页的速度 常见 http 缓存的类型 私有缓存（一般为本地浏览器缓存）代理缓存 然后谈谈本地缓存本地缓存是指浏览器请求资源时命中了浏览器本地的缓存资源，浏览器并不会发送真正的请求给服务器了。 第一次浏览器发送请求给服务器时，此时浏览器还没有本地缓存副本，服务器返回资源给浏览器，响应码是200 OK，浏览器收到资源后，把资源和对应的响应头一起缓存下来第二次浏览器准备发送请求给服务器时候，浏览器会先检查上一次服务端返回的响应头信息中的Cache-Control，它的值是一个相对值，单位为秒，表示资源在客户端缓存的最大有效期，过期时间为第一次请求的时间减去Cache-Control的值，过期时间跟当前的请求时间比较，如果本地缓存资源没过期，那么命中缓存，不再请求服务器如果没有命中，浏览器就会把请求发送给服务器，进入缓存协商阶段。 与本地缓存相关的头有：Cache-Control、Expires，Cache-Control有多个可选值代表不同的意义，而Expires就是一个日期格式的绝对值 缓存位置浏览器缓存的位置的话，可以分为四种,优先级从高到低排列分别👇 Service Worker Memory Cache Disk Cache Push Cache Service Worker 这个应用场景比如PWA，它借鉴了Web Worker思路，由于它脱离了浏览器的窗体，因此无法直接访问DOM。 它能完成的功能比如：离线缓存、消息推送和网络代理，其中离线缓存就是Service Worker Cache。 Memory Cache 指的是内存缓存，从效率上讲它是最快的，从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。 Disk Cache 存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，优势在于存储容量和存储时长。 Push Cache 推送缓存，这算是浏览器中最后一道防线吧，它是HTTP&#x2F;2的内容","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[]},{"title":"事件循环和宏任务微任务","slug":"javascript/宏队列和微队列的执行顺序","date":"2022-04-27T06:54:37.000Z","updated":"2022-05-09T06:24:29.281Z","comments":true,"path":"2022/04/27/javascript/宏队列和微队列的执行顺序/","link":"","permalink":"http://example.com/2022/04/27/javascript/%E5%AE%8F%E9%98%9F%E5%88%97%E5%92%8C%E5%BE%AE%E9%98%9F%E5%88%97%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/","excerpt":"","text":"事件循环 宏任务和微任务事件循环 js引擎首先必须先执行所有的初始化同步任务代码,遇到异步任务，提交给’异步进程处理’,主线程执行栈会不停监听消息队列是否有异步任务，称位事件循环 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 宏队列: 用于保存待执行的宏任务（回调）,比如：定时器回调，DOM事件回调,ajax回调 微队列: 用来保存待执行的微任务（回调）,比如：promise的回调，MutationObserver的回调 每次准备取出第一个宏任务执行前，都要将所有的微任务一个一个取出来执行，也就是微任务比宏任务先执行","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[]},{"title":"webpack_优化","slug":"webpack/webpack-优化","date":"2022-04-22T12:45:36.000Z","updated":"2022-04-26T13:29:29.410Z","comments":true,"path":"2022/04/22/webpack/webpack-优化/","link":"","permalink":"http://example.com/2022/04/22/webpack/webpack-%E4%BC%98%E5%8C%96/","excerpt":"","text":"1、 如何提高webpack的构建速度？ 多入口情况下，使用CommonsChunkPlugin来提取公共代码 通过externals配置来提取常用库 利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。 使用Happypack 实现多线程加速编译 使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度 使用Tree-shaking和Scope Hoisting来剔除多余代码 2、 如何利用webpack来优化前端性能？（提高性能和体验）!用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。 压缩代码 删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css 利用CDN加速 在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径 删除死代码 将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数–optimize-minimize来实现 提取公共代码 异步组件 — 异步图片 — 配置webpack对小图片打包成base64字符 减少io请求 3、 怎么配置单页应用？怎么配置多页应用？ 单页应用 可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可 多页应用 可以使用webpack的 AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 4、 如何提升webpack的运行速度(开发环境) ,有哪些策略？ 多入口情况下，使用CommonsChunkPlugin来提取公共代码 通过externals配置来提取常用库 利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。 使用Happypack 实现多线程加速编译 使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度 使用Tree-shaking和Scope Hoisting来剔除多余代码 JS代码压缩 terser是一个JavaScript的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让bundle更小。在production模式下，webpack 默认就是使用 TerserPlugin 来处理我们的代码的。 TerserPlugin常用的属性如下： - extractComments：默认值为true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释 - parallel：使用多进程并发运行提高构建的速度，默认值是true，并发运行的默认数量： os.cpus().length - 1 - terserOptions：设置我们的terser相关的配置： compress：设置压缩相关的选项，mangle：设置丑化相关的选项，可以直接设置为true mangle：设置丑化相关的选项，可以直接设置为true toplevel：底层变量是否进行转换keep_classnames：保留类的名称 keep_fnames：保留函数的名称 代码压缩 cssCSS压缩通常用于去除无用的空格等，不过因为很难去修改选择器、属性的名称、值等，所以我们可以使用另外一个插件：css-minimizer-webpack-plugin Html文件代码压缩 文件大小压缩 对文件的大小进行压缩，可以有效减少http传输过程中宽带的损耗，文件压缩需要用到 compression-webpack-plugin插件 图片压缩 如果我们对bundle包进行分析，会发现图片等多媒体文件的大小是远远要比 js、css 文件要大的，所以图片压缩在打包方面也是很重要的 Tree Shaking Tree Shaking 是一个术语，在计算机中表示消除死代码，依赖于ES Module的静态语法分析。在webpack实现Trss shaking有两种不同的方案： usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的 sideEffects：跳过整个模块&#x2F;文件，直接查看该文件是否有副作用 usedExports的配置方法很简单，只需要将usedExports设为true即可，如下。而sideEffects则用于告知webpack compiler在编译时哪些模块有副作用，配置方法是在package.json中设置sideEffects属性。如果sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports，如果有些文件需要保留，可以设置为数组的形式。 代码分离 默认情况下，所有的JavaScript代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载， 就会影响首页的加载速度。如果可以分出出更小的bundle，以及控制资源加载优先级，从而优化加载性能。 代码分离可以通过splitChunksPlugin来实现，该插件webpack已经默认安装和集成，只需要配置即可。 splitChunks有如下几个属性： Chunks：对同步代码还是异步代码进行处理 minSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分 maxSize： 将大于maxSize的包，拆分为不小于minSize的包 minChunks：被引入的次数，默认是1 内联 chunk 可以通过InlineChunkHtmlPlugin插件将一些chunk的模块内联到html，如runtime的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大但是必须加载的，比如：总结一下，Webpack对前端性能的优化，主要是通过文件体积大小入手，主要的措施有分包、减少Http请求次数等。 5、 npm打包时需要注意哪些？如何利用webpack来更好的构建？Npm是目前最大的 JavaScript 模块仓库，里面有来自全世界开发者上传的可复用模块。你可能只是JS模块的使用者，但是有些情况你也会去选择上传自己开发的模块。关于NPM模块上传的方法可以去官网上进行学习，这里只讲解如何利用webpack来构建。 NPM模块需要注意以下问题：要支持CommonJS模块化规范，所以要求打包后的最后结果也遵守该规则。Npm模块使用者的环境是不确定的，很有可能并不支持ES6，所以打包的最后结果应该是采用ES5编写的。并且如果ES5是经过转换的，请最好连同SourceMap一同上传。Npm包大小应该是尽量小（有些仓库会限制包大小）发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。UI组件类的模块应该将依赖的其它资源文件，例如.css文件也需要包含在发布的模块里。 6、 什么是长缓存？在webpack中如何做到长缓存优化？ 浏览器在用户访问页面的时候，为了加快加载速度，会对用户访问的静态资源进行存储，但是每一次代码升级或者更新，都需要浏览器去下载新的代码，最方便和最简单的更新方式就是引入新的文件名称。 在webpack中，可以在output给出输出的文件制定chunkhash，并且分离经常更新的代码和框架代码，通过NameModulesPlugin或者HashedModulesPlugin使再次打包文件名不变。 7、 在项目中tree-shaking摇树不是很干净，有什么解决方案？ 在webpack.config.js中通过 来进行tree-shaking 但是单单指定这一个配置 不是很干净 有些模块导入，只要被引入， 就会对应用程序产生重要的影响。一个很好的例子就是全局样式表，或者设置全局配置的JavaScript 文件。 8、 怎么提高webpack的打包效率？ 开发环境优化 开启热模块替换（HMR） 使用 source-map 进行源代码映射 将只需要被loader执行一次的规则放到 oneOf 里面去 生产环境优化 对资源进行缓存 使用tree shaking（树摇） 使用code split 进行代码分割 文件懒加载和预加载 多进程打包 使用PWA（离线加载） 使用externals 忽略某些包，然后通过cdn引入 使用dll 技术对某些库（第三方库）进行单独打包 9、 按需加载的原理 使用符合ECMAScript 提案的import()语法 使用 webpack 特定的require.ensure 10、 预获取&#x2F;预加载模块Webpack v4.6.0+ 增加了对预获取和预加载的支持。 在声明 import 时，使用下面这些内置指令，可以让 webpack 输出 &quot;resource hint(资源提示)&quot;，来告知浏览器 ● prefetch(预获取)：将来某些导航下可能需要的资源 ● preload(预加载)：当前导航下可能需要资源 添加第二句魔法注释： webpackPrefetch: true 告诉 webpack 执行预获取。这会生成 &lt;link rel&#x3D;&quot;prefetch&quot; href&#x3D;&quot;math.js&quot;&gt; 并追加到页面头部，指示着浏览器在闲置时间预取 math.js 文件。 12. 什么是Tree-sharking? Tree是树，sharking是摇晃的意思。那么树摇晃的时候，肯定会’摇’下来一些无用的叶子。从编程的角度思考，如果假设我们的代码是一棵树（Tree），那么摇下来的无用的的叶子是什么呢？当然是无用的代码啦，他有个专业的术语，叫做dead-code（死码） 指打包中去除那些引入了但在代码中没用到的死代码。在wepack中js treeshaking通过UglifyJsPlugin来进行，css中通过purify-CSS来进行。","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[]},{"title":"webpack5_Loader","slug":"webpack/webpack-Loader","date":"2022-04-21T06:47:27.000Z","updated":"2022-04-26T13:49:40.647Z","comments":true,"path":"2022/04/21/webpack/webpack-Loader/","link":"","permalink":"http://example.com/2022/04/21/webpack/webpack-Loader/","excerpt":"","text":"webpack Loader整理1. Loader机制的作用是什么？ webpack 本身只能处理 JavaScript 和 JSON 文件，而 loader 为 webpack 添加了处理其他类型文件的能力。 webpack默认只能打包js文件，配置里的module.rules数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换打包成js。注意：use属性的值需要是一个由 Loader 名称组成的数组，Loader 的执行顺序是由后到前的； 每一个 Loader 都可以通过 URL querystring 的方式传入参数，例如css-loader?minimize 中的minimize告诉css-loader要开启 CSS 压缩。 2. 有哪些常见的Loader？他们是解决什么问题的？file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去 source-map-loader：加载额外的 Source Map 文件，以方便断点调试 image-loader：加载并且压缩图片文件 babel-loader：把 ES6 转换成 ES5 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。 eslint-loader：通过 ESLint 检查 JavaScript 代码 3. Webpack 的 Loader 是什么？Webpack 只能理解 JavaScript 和 JSON 文件，这是 Webpack 开箱可用的自带能力。loader 可以让 Webpack 能够去处理其他类型的文件，chunk 文件以供应用程序使用，以及被添加到依赖图中，也可将内联图像转换为 data URL。简单来说，loader 可以将一段代码转换成另一端代码，通常用来将一段特殊代码转换成一段浏览器可识别的代码。 loader 有两个属性： test，正则表达式，用于识别出哪些文件会被转换， use 定义在进行转换时应该使用哪个 loader，可以是字符串、数组和对象。","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[]},{"title":"webpack5_Plugin","slug":"webpack/webpack-Plugin","date":"2022-04-21T01:18:03.000Z","updated":"2022-04-26T14:05:31.611Z","comments":true,"path":"2022/04/21/webpack/webpack-Plugin/","link":"","permalink":"http://example.com/2022/04/21/webpack/webpack-Plugin/","excerpt":"","text":"– webpack Plugin整理1. Plugin（插件）的作用是什么？通过安装和配置第三方的插件，可以拓展 webpack 的能力，从而让 webpack 用起来更方便。最常用的webpack 插件有如下两个： webpack-dev-server 类似于 node.js 阶段用到的 nodemon 工具每当修改了源代码，webpack 会自动进行项目的打包和构建 html-webpack-plugin webpack 中的 HTML 插件（类似于一个模板引擎插件）可以通过此插件自定制 index.html 页面的内容 webpack-dev-server 可以让 webpack 监听项目源代码的变化，从而进行自动打包构建。 修改package.json -&gt; scripts中的dev命令： &quot;scripts&quot;:&#123; &quot;dev&quot;：&quot;webpack serve&quot;，&#x2F;&#x2F; script 节点下的脚本,可以通过 npm run 执行 &#125; 2. 有哪些常见的Plugin？他们是解决什么问题的？define-plugin：定义环境变量 commons-chunk-plugin：提取公共代码 uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码 purgecss-webpack-plugin：擦除无用css happypack：多线程处理打包 webpack-bundle-analyzer：打包分析 speed-measure-webpack-plugin：构建速度分析 html-webpack-plugin：为html文件中引入的外部资源如script、link动态添加每次compile后的hash，防止引用缓存的外部文件问题 3. Webpack 的 Plugin 是什么？plugin是插件的意思，通常是用于对某个现有的架构进行扩展。 &#x3D;&#x3D;&gt; webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等。 4. Loader和Plugin的不同？不同的作用 Loader直译为”加载器”。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力 Plugin直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 不同的用法 Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options） Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。 4.描述一下编写loader或plugin的思路？Loader像一个&quot;翻译官&quot;把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。 编写Loader时要遵循单一原则，每个Loader只做一种&quot;转义&quot;工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。 相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[]},{"title":"webpack整理","slug":"webpack/webpack概念","date":"2022-04-20T05:44:06.000Z","updated":"2022-04-26T08:53:26.601Z","comments":true,"path":"2022/04/20/webpack/webpack概念/","link":"","permalink":"http://example.com/2022/04/20/webpack/webpack%E6%A6%82%E5%BF%B5/","excerpt":"","text":"– webpack5概念1.谈谈你对Webpack的理解？是一个模块化打包工具，将不同的资源和文件，进行打包，合并在一个文件里。 1、依赖管理：方便引用第三方模块，让模块更容易复用、避免全局注入导致的冲突、、避免重复加载或者加载不必要的模块 2、合并代码：把各个分散的模块集中打包成大文件，减少HTTP的链接的请求次数，配合uglify.js可以减少、优化代码的体积 3、各种插件：babel把ES6+转[webpack5整理]()化为ES5-，eslint可以检查编译时的各种错误 2.webpack的工作原理?基本概念1. Entry:入口指示webpack以哪个文件为入口起点开始打包，分析构建内部依赖图 2. output:输出指示webpack的打包后的资源bundles输出到哪里去，以及如何命名 3. Loader:让webpack能够去处理哪些非JavaScrip文件（webpack自身只理解javaScript) 4. plugin:插件可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等 5. mode:模式指示webpack使用相应模式的配置 流程概括webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 1. 初始化参数：从配置文件和Shell语句中读取与合并参数，得出最终的参数； 2. 开始编译： 用上一步得到的参数初始化Complier对象，加载所有配置的插件，执行对象的run方法开始执行编译； 3. 确定入口： 根据配置中的entry找出所有入口文件； 4. 编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理； 5. 完成模块编译： 在经过第4步使用Loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及他们之间的依赖关系； 6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会； 7. 输出完成： 在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。 在以上过程中，webpack会在特定的时间点广播出特定的时间，插件在监听到感兴趣的时间后会执行特定的逻辑，并且插件可以调用Webpack提供的API改变Webpack的运行结果。 流程细节 Webpack的构建流程可以分为以下三个阶段： 初始化：启动构建，读取与合并配置参数，加载Plugin，实例化Complier. 编译：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件内容，再找到该Module依赖的Module，递归地进行编译处理。 输出： 对编译后的Module组合成Chunk，把Chunk转换成文件，输出到文件系统。 3.webpack4和webpack5的区别？更快的构建速度 更高的版本要求 更灵活的模块组合 更智能的缓存优化 更小的体积 webpack4 上需要下载安装 terser-webpack-plugin 插件 webpack5 内部本身就自带 js 压缩功能，他内置了 terser-webpack-plugin 插件，我们不用再下载安装。而且在 mode&#x3D;“production” 的时候会自动开启 js 压缩功能。 webpack4 缓存配置 &#x3D;&#x3D;&gt; npm install hard-source-webpack-plugin -D webpack5 缓存配置 &#x3D;&#x3D;&gt; webpack5 内部内置了 cache 缓存机制。直接配置即可。 &#x3D;&#x3D;&gt; cache 会在开发模式下被设置成 type： memory 而且会在生产模式把cache 给禁用掉。 webpack4 启动服务 &#x3D;&#x3D;&gt; 通过 webpack-dev-server 启动服务 webpack5 启动服务 &#x3D;&#x3D;&gt; 内置使用 webpack serve 启动，但是他的日志不是很好，所以一般都加都喜欢用 webpack-dev-server 优化。 打包的区别 ● webpack4打包:即使后续没有使用到num1的函数，依然会将代码打包进去 ● webpack5打包:后续没有使用到num1的函数，不会将代码打包进去 输出代码的区别 ● webpack4只能输出es5的代码 ● webpack5新增属性output.ecmaVersion，可以生成ES5和ES6的代码 4. 前端代码为何要进行构建和打包？ 代码方面体积更小，加载更快（tree-shaking，压缩合并） 编译高级语言和语法（ts，es6，模块化） 兼容性和错误提示（polyfill，postcss，eslint） 研发流程统一、高效的开发环境 统一的构建流程和产出标准 集成公司构建规范（提测，上线） 5. webpack的优缺点？ 优点 webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD&#x2F;CMD 的支持也很全面，方便旧项目进行代码迁移。 能被模块化的不仅仅是 JS 了。 开发便捷，能替代部分 grunt&#x2F;gulp 的工作，比如打包、压缩混淆、图片转base64等。 扩展性强，插件机制完善 缺点 配置复杂 不分包bundle.js体积庞大 只能用于采用模块化开发的项目 打包慢 ES模块除Module外全用babel转换，但是一部分ES2015 语法的 firefox 与 chrome 浏览器中能直接跑的代码，无法用 webpack 编译 6. 什么是bundle，什么是chunk，什么是modulebundle： 是由webpack打包出来的文件 chunk： 是指webpack在进行模块依赖分析的时候，代码分割出来的代码块 module： 是开发中的单个模块","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[]},{"title":"深拷贝和浅拷贝","slug":"javascript/深拷贝和浅拷贝","date":"2022-03-21T05:12:39.000Z","updated":"2022-04-27T01:24:23.653Z","comments":true,"path":"2022/03/21/javascript/深拷贝和浅拷贝/","link":"","permalink":"http://example.com/2022/03/21/javascript/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"深拷贝和浅拷贝浅拷贝和深拷贝都只针对于引用数据类型 浅拷贝 只复制指向对象的指针,而不复制对象本身，新旧对象还是共享同一块内存; 深拷贝 另外创造一个一模一样的对象,新对象跟原对象不共享内存,修改新对象不会影响到原对象 浅拷贝实现方法1.Object.assign方法 var obj &#x3D; &#123; a:1, b:2 &#125; var obj1 &#x3D; Object.assign(&#123;&#125;,obj) obj1.a &#x3D; 3: console.log(obj.a) &#x2F;&#x2F; 3 2.解构赋值 var obj1 &#x3D; &#123;a: 1, b: 2&#125; var obj2 &#x3D; &#123;...obj1&#125; obj2.a &#x3D; 4 console.log(obj1, obj2) 深拷贝实现方法1.json.stringify()方法 var obj1 &#x3D; [&#123; name: &#39;臧三&#39;, childs: [&#39;小明&#39;, &#39;小芳&#39;] &#125;] var obj2 &#x3D; JSON.parse(JSON.stringify(obj1)) obj2[0].childs &#x3D; [] console.log(obj1, obj2) 2.递归方法 var obj1 &#x3D; [&#123; name: &#39;臧三&#39;, childs: [&#39;小明&#39;, &#39;小芳&#39;], fn: function() &#123;&#125;, age: undefined &#125;] var obj2 &#x3D; extend(obj1) obj2[0].childs &#x3D; [] console.log(obj1, obj2) function extend(data) &#123; if (typeof data &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; data) &#123; let val &#x3D; typeof data.length &#x3D;&#x3D;&#x3D; &#39;number&#39; ? [] : &#123;&#125; for(let i in data) &#123; val[i] &#x3D; extend(data[i]) &#125; return val &#125; else &#123; return data &#125; &#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[]},{"title":"闭包的理解","slug":"javascript/闭包的理解","date":"2022-03-14T00:40:47.000Z","updated":"2022-04-27T01:10:12.654Z","comments":true,"path":"2022/03/14/javascript/闭包的理解/","link":"","permalink":"http://example.com/2022/03/14/javascript/%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"– 闭包的理解一个函数和对其他周围状态的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包。闭包可以在一个内层函数中访问到外层函数的作用域。 闭包的特点 可以让外部访问函数内部的变量。 可以避免使用全局变量。防止全局变量污染。 可以让局部变量常驻在内存中 会造成内存泄露(有一个内存空间长期被占用，而不被释放) 闭包示例 function fn1()&#123; var max &#x3D; 10; return function (x) &#123; if(x &gt; max)&#123; console.log(x); &#125; &#125; &#125; var fn2 &#x3D; fn1(); fn2(20);","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[]},{"title":"防抖与节流","slug":"javascript/防抖与节流","date":"2022-02-27T06:24:41.000Z","updated":"2022-04-27T01:29:28.298Z","comments":true,"path":"2022/02/27/javascript/防抖与节流/","link":"","permalink":"http://example.com/2022/02/27/javascript/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/","excerpt":"","text":"防抖与节流防抖在事件被触发的n秒后再执行回调,如果这n秒又被触发，则重新计时.高频操作下，只执行最后一次. &lt;script&gt; &#x2F;&#x2F; 防抖 用户触发事件过于频繁 let inp &#x3D; document.getElementsByTagName(&#39;input&#39;) inp[0].oninput &#x3D; deco(function () &#123; console.log(this.value) &#125;, 500) function deco(fn, time) &#123; let t &#x3D; null; return function () &#123; if (t) &#123; clearTimeout(t) &#125; t &#x3D; setTimeout(() &#x3D;&gt; &#123; fn.call(this) &#125;, time) &#125; &#125; &lt;&#x2F;script&gt; 节流一定时间内 控制触发的次数 &lt;script&gt; window.onscroll &#x3D; fn(function () &#123; console.log(1111111) &#125;, 500) function fn(fn1, time) &#123; let flag &#x3D; true; return function () &#123; if (flag) &#123; setTimeout(() &#x3D;&gt; &#123; fn1.call(this) flag &#x3D; true &#125;, time) &#125; flag &#x3D; false; &#125; &#125; &lt;&#x2F;script&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[]},{"title":"实现异步的方法","slug":"javascript/实现异步的方法","date":"2022-02-21T05:30:29.000Z","updated":"2022-04-28T05:42:14.553Z","comments":true,"path":"2022/02/21/javascript/实现异步的方法/","link":"","permalink":"http://example.com/2022/02/21/javascript/%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"实现异步的方法 回调函数(Callback) 事件监听 发布订阅 promise 生成器(Generators&#x2F;yield) async&#x2F;await js异步编程进化史: callback –&gt; promise –&gt; generator –&gt;async + await async&#x2F;await函数的实现，就是将Generator函数和自动执行器，包装在一个函数里async&#x2F;await 可以说是异步终极解决方案了。 async&#x2F;await 函数相对于Promise,优势体现在：处理then的调用链，能够更加清晰准确的写出代码 并且也能优雅的解决回调地狱的问题。 当然async&#x2F;await也存在一些缺点，因为await将异步代码改造成了同步代码，如果多个异步代码没有 依赖性却使用了await会导致性能上的降低，代码没有依赖的话，完全可以使用Promise.all的方式。 async&#x2F;await函数对Generator函数的改造体现以下三点:内置执行器。Generator函数的执行必须靠执行器，所以才有了co函数库，而async函数自带执行器。也就是说： async函数的执行，与普通函数一模一样，只要一行。 更广的实用性。co函数库约定，yield命令后面只能是Thunk函数或者Promise对象，而async函数的await命令后面， 可以跟Promise对象和原始类型的值（数值，字符串和布尔值，但这时等同于同步操作）。 更好的语义。async和await，比起星号和yield，语义更清楚了，async表示函数里有异步操作，await表示紧跟在后面的 表达式需要等待结果。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[]},{"title":"面向对象的三大特征","slug":"javascript/面向对象的三大特征","date":"2022-01-28T06:34:16.000Z","updated":"2022-04-27T06:44:58.550Z","comments":true,"path":"2022/01/28/javascript/面向对象的三大特征/","link":"","permalink":"http://example.com/2022/01/28/javascript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81/","excerpt":"","text":"面向对象的三大特征面向对象是一种程序设计思想，将数据和处理数据的程序封装到对象中。 封装: 将对象运行所需的资源封装在程序对象中，可以隐藏实现的细节，使得代码模块化. 继承: 继承可以解决代码复用。当多个类存在相同的属性和方法时,可以将这些类中抽象出父类,在父类中定义这些相同的属性和方法，所有子类不需要重新定义这些方法和属性，只需要通过继承父类中的方法. 多态: 多态是指一个引用(类型)在不同情况下的多种状态.多态是通过指向父类的引用，来调用在不同子类中实现的方法。多态分为两种:一种是行为多态和对象的多态. 优点: 提高代码的复用性及可维护性。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[]},{"title":"js类型检测","slug":"javascript/js类型检测","date":"2021-12-05T02:03:22.000Z","updated":"2022-05-09T06:38:42.971Z","comments":true,"path":"2021/12/05/javascript/js类型检测/","link":"","permalink":"http://example.com/2021/12/05/javascript/js%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B/","excerpt":"","text":"JS内置类型 JavaScript一共有8种数据类型，其中有7种基本数据类型：Undefined、Null、Boolean、Number、String、Symbol（es6新增，表示独一无二的值）和BigInt（es10新增）； 原始数据类型基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。 引用数据类型引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念；占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 数据类型检测 typeof typeof 对于原始类型来说，除了 null 都可以显示正确的类型 instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype constructor 如果我创建一个对象，更改它的原型，constructor就会变得不可靠了 Object.prototype.toString.call() toString() 是 Object 的原型方法，调用该方法，可以统一返回格式为 “[object Xxx]” 的字符串","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[]},{"title":"vue中$nextTick作用于原理","slug":"Vue/vue中-nextTick作用于原理","date":"2021-11-12T05:31:48.000Z","updated":"2022-05-01T05:42:05.217Z","comments":true,"path":"2021/11/12/Vue/vue中-nextTick作用于原理/","link":"","permalink":"http://example.com/2021/11/12/Vue/vue%E4%B8%AD-nextTick%E4%BD%9C%E7%94%A8%E4%BA%8E%E5%8E%9F%E7%90%86/","excerpt":"","text":"vue中$nextTick的作用与原理作用：是为了可以获取更新后的DOM。 由于Vue DOM更新是异步执行的,即修改数据时，视图不会立即更新，而是会监听数据变化,并缓存在同一事件循环中,等同一数据循环中,等统一数据循环中的所有数据变化完成之后,再统一进行视图更新.为了确保得到更新后的DOM，所以设置了Vue.nextTick(),就是在下次DOM更新循环结束之后执行延迟回调.在修改数据之后立即使用这个方法,获取更新后的DOM。 原理在下次DOM更新循环结束之后执行延迟回调.nextTick主要使用了宏任务和微任务.根据执行环境分别尝试采用 Promise MutationObserver setlmmediate如果以上都不行则采用setTimeout 定义了一个异步方法,多次调用nextTick会将方法存入队列当中，通过这个异步方法清空当前队列.","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[]},{"title":"浏览器如何渲染网页?","slug":"浏览器/浏览器如何渲染网页","date":"2021-08-06T00:51:55.000Z","updated":"2022-05-09T06:32:08.313Z","comments":true,"path":"2021/08/06/浏览器/浏览器如何渲染网页/","link":"","permalink":"http://example.com/2021/08/06/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E7%BD%91%E9%A1%B5/","excerpt":"","text":"渲染机制浏览器渲染一共有五步 处理 HTML 并构建 DOM 树。 处理 CSS构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，计算每个节点的位置。 调用 GPU 绘制，合成图层，显示在屏幕上 第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染 重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘 回流是布局或者几何属性需要改变就称为回流。回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流 以下几个动作可能会导致性能问题 改变 window 大小 改变字体 添加或删除样式 文字改变 定位或者浮动 盒模型","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[]},{"title":"单页应用和多页应用的区别","slug":"Vue/单页应用和多页应用的区别","date":"2021-04-28T06:44:22.000Z","updated":"2022-05-09T06:24:29.267Z","comments":true,"path":"2021/04/28/Vue/单页应用和多页应用的区别/","link":"","permalink":"http://example.com/2021/04/28/Vue/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E5%92%8C%E5%A4%9A%E9%A1%B5%E5%BA%94%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"单页应用和多页应有的区别?概念： SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。 MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[]},{"title":"HashRouter和HistoryRouter的区别和原理","slug":"Vue/HashRouter和HistoryRouter的区别和原理","date":"2021-04-03T02:03:01.000Z","updated":"2022-05-03T02:18:12.974Z","comments":true,"path":"2021/04/03/Vue/HashRouter和HistoryRouter的区别和原理/","link":"","permalink":"http://example.com/2021/04/03/Vue/HashRouter%E5%92%8CHistoryRouter%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%8E%9F%E7%90%86/","excerpt":"","text":"HashRouter和HistoryRouter的区别和原理vue-router是Vue官方的路由管理器。它和Vue.js的核心深度集成，让构建单页面应用变得简单。vue-router默认hash模式，还有一种是history模式。 原理 hash路由:&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &gt;hash模式的工作原理是hashchange事件，可以在window监听hash的变化，我们在url后面随便添加一个#xx触发这个事件。vue-router默认是hash模式–使用url的hash来模拟一个完整的url，于是当url改变的时候，页面不会重新加载，也就是单页应用当#后面的hash发生变化，不会导致浏览器向服务器发出请求，浏览器不发出请求就不会刷新页面，并且会触发hashChange这个事件，通过监听hash值的变化来实现更新页面部分内容操作对于hash模式会创建hashHistory对象，在访问不同的路由的时候，会发生两件事 ——- &gt;HashHistory.push()将新的路由添加到浏览器访问的历史的栈顶，和hasHistory.replace()替换到当前栈顶路由 history路由:&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &gt;主要使用HTML5的pushState（）和replaceState（）这两个api结合window.popstate事件（监听浏览器前进后退）来实现的，pushState()可以改变url地址且不会发送请求，replaceState()可以读取历史记录栈，还可以对浏览器记录进行修改 区别 hash模式不美观，history模式较优雅 pushState设置的新URL可以与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中，而hash设置的新值与原来不一样才会触发记录添加到栈中 pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串 pushState可额外设置title属性供后续使用 hash兼容IE8以上，history兼容IE10以上 history模式需要后端配合将所有访问都指向index.html，否则用户刷新页面,会导致404错误 使用方法 &lt; script &gt; &#x2F;&#x2F; hash路由原理*************************** &#x2F;&#x2F; 监听hashchange方法 window.addEventListener(&#39;hashchange&#39;,()&#x3D;&gt;&#123; div.innerHTML&#x3D;location.hash.slice(1) &#125;) &#x2F;&#x2F; history路由原理************************ &#x2F;&#x2F; 利用html5的history的pushState方法结合window.popstate事件（监听浏览器前进后退） function routerChange (pathname)&#123; history.pushState(null,null,pathname) div.innerHTML&#x3D; location.pathname &#125; window.addEventListener(&#39;popstate&#39;,()&#x3D;&gt;&#123; div.innerHTML &#x3D; location.pathname &#125;) &lt;&#x2F;script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[]},{"title":"new_Vue以后发生的事情","slug":"Vue/new-Vue以后发生的事情","date":"2021-03-19T07:36:16.000Z","updated":"2022-04-28T07:45:16.458Z","comments":true,"path":"2021/03/19/Vue/new-Vue以后发生的事情/","link":"","permalink":"http://example.com/2021/03/19/Vue/new-Vue%E4%BB%A5%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%E6%83%85/","excerpt":"","text":"聊一聊new Vue之后发生的事情? new Vue会调用Vue原型链上的_init方法对Vue实例进行初始化; 首先是initLifecycle初始化生命周期,对Vue实例内部的一些属性(如 children、parent、isMounted)进行初始化； initEvents，初始化当前实例上的一些自定义事件(Vue.$on); initRender,解析slots绑定在Vue实例上，绑定createElement方法在实例上； 完成对生命周期、自定义事件等一系列属性的初始化后，触发生命周期钩子beforeCreate； initInjections，在初始化data和props之前完成依赖注入（类似于React.Context）; initState，完成对data和props的初始化，同时对属性完成数据劫持内部，启用监听者对数据进行监听（更改）; initProvide，对依赖注入进行解析； 完成对数据（state状态）的初始化后，触发生命周期钩子created； 进入挂载阶段，将vue模板语法通过vue-loader解析生成虚拟dom数，虚拟dom树与数据完成双向绑定，触发生命周期钩子beforeMount； 将解析好的虚拟dom树通过vue渲染成真实DOM，触发生命周期钩子mounted；","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[]},{"title":"vue首屏白屏怎么解决?","slug":"Vue/vue首屏白屏怎么解决","date":"2021-03-17T06:52:49.000Z","updated":"2022-04-28T07:00:31.236Z","comments":true,"path":"2021/03/17/Vue/vue首屏白屏怎么解决/","link":"","permalink":"http://example.com/2021/03/17/Vue/vue%E9%A6%96%E5%B1%8F%E7%99%BD%E5%B1%8F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3/","excerpt":"","text":"vue首屏白屏怎么解决？ 路由懒加载 vue-cli开启打包压缩 和后台配合gzip访问 进行cdn加速 开启vue服务器渲染模式 用webpack的externals属性把不需要打包的库文件分离出去，减少打包后的文件大小 在生产环境中删除不必要的console.log() plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; &#x2F;&#x2F;添加-删除 compress:&#123; warnings:false, drop_debugger:true, drop_console:true &#125;, sourceMap:true &#125;), 开启nginx的gzip,在nginx.conf配置文件中配置 http &#123; &#x2F;&#x2F;在http中配置如下代码， gzip on; gzip_disable &quot;msie6&quot;; gzip_vary on; gzip_proxied any; gzip_comp_level 8; #压缩级别 gzip_buffers 16 8k; #gzip_http_version 1.1; gzip_min_length 100; &#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[]},{"title":"受控组件和非受控组件","slug":"React/受控组件和非受控组件","date":"2020-12-12T07:20:35.000Z","updated":"2022-05-13T11:23:01.331Z","comments":true,"path":"2020/12/12/React/受控组件和非受控组件/","link":"","permalink":"http://example.com/2020/12/12/React/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/","excerpt":"","text":"受控组件和非受控组件&lt;FInput value &#x3D; &#123;x&#125; onChange &#x3D; &#123;fn&#125; &#x2F;&gt; &#x2F;&#x2F; 上面的是受控组件 下面的是非受控组件 &lt;FInput defaultValue &#x3D; &#123;x&#125; &#x2F;&gt; 当你一个组件同时传递一个value以及onChange事件时，它就是一个受控组件，收入输出都是我来控制的。 第二个只是传递了默认的初时值，并没有传onchange事件， 非受控组件是一种反模式，它的值不受组件自身的state或props控制","categories":[{"name":"React","slug":"React","permalink":"http://example.com/categories/React/"}],"tags":[]},{"title":"React Hook","slug":"React/React-Hook","date":"2020-09-12T05:48:35.000Z","updated":"2022-05-13T11:11:54.269Z","comments":true,"path":"2020/09/12/React/React-Hook/","link":"","permalink":"http://example.com/2020/09/12/React/React-Hook/","excerpt":"","text":"代码逻辑聚合，逻辑复用 HOC嵌套地狱 代替class React 中通常使用 类定义 或者 函数定义 创建组件: 在类定义中，我们可以使用到许多 React 特性，例如 state、 各种组件生命周期钩子等 ，但是在函数定义中，我们却无能为力，因此 React 16.8 版本推出了一个新功能 (React Hooks)，通过它，可以更好的在函数定义组件中使用 React 特性。 函数组件与类组件的对比：无关“优劣”，只谈“不同” 类组件需要继承 class，函数组件不需要； 类组件可以访问生命周期方法，函数组件不能； 类组件中可以获取到实例化后的 this，并基于这个 this 做各种各样的事情，而函数组件不可以； 类组件中可以定义并维护 state（状态），而函数组件不可以； 但是类组件它太重了，对于解决许多问题来说，编写一个类组件实在是一个过于复杂的姿势。复杂的姿势必然带来高昂的理解成本，这也是我们所不想看到的 react hooks的好处: 跨组件复用: 其实 render props &#x2F; HOC 也是为了复用，相比于它们，Hooks 作为官方的底层API，最为轻量，而且改造成本小，不会影响原来的组件层次结构和传说中的嵌套地狱； 类定义更为复杂 不同的生命周期会使逻辑变得分散且混乱，不易维护和管理； 时刻需要关注this的指向问题； 代码复用代价高，高阶组件的使用经常会使整个组件树变得臃肿； 状态与UI隔离: 正是由于 Hooks 的特性，状态逻辑会变成更小的粒度，并且极容易被抽象成一个自定义 Hooks，组件中的状态和 UI 变得更为清晰和隔离. 注意: 避免在 循环&#x2F;条件判断&#x2F;嵌套函数 中调用 hooks，保证调用顺序的稳定； 只有 函数定义组件 和 hooks 可以调用 hooks，避免在 类组件 或者 普通函数 中调用； 不能在useEffect中使用useState，React 会报错提示； 类组件不会被替换或废弃，不需要强制改造类组件，两种方式能并存； 重要钩子 状态钩子 (useState): 用于定义组件的 State，其到类定义中this.state的功能； &#x2F;&#x2F; useState 只接受一个参数: 初始状态 &#x2F;&#x2F; 返回的是组件名和更改该组件对应的函数 const [flag, setFlag] &#x3D; useState(true); &#x2F;&#x2F; 修改状态 setFlag(false) &#x2F;&#x2F; 上面的代码映射到类定义中: this.state &#x3D; &#123; flag: true &#125; const flag &#x3D; this.state.flag const setFlag &#x3D; (bool) &#x3D;&gt; &#123; this.setState(&#123; flag: bool, &#125;) &#125; 生命周期钩子 (useEffect): 类定义中有许多生命周期函数，而在 React Hooks 中也提供了一个相应的函数 (useEffect)， 这里可以看做componentDidMount、componentDidUpdate和componentWillUnmount的结合。 seEffect(callback, [source])接受两个参数 callback: 钩子回调函数； source: 设置触发条件，仅当 source 发生改变时才会触发； useEffect钩子在没有传入[source]参数时，默认在每次 render 时都会优先调用上次保存的回调中返回的函数，后再重新调用回调； useEffect(() &#x3D;&gt; &#123; &#x2F;&#x2F; 组件挂载后执行事件绑定 console.log(&#39;on&#39;) addEventListener() &#x2F;&#x2F; 组件 update 时会执行事件解绑 return () &#x3D;&gt; &#123; console.log(&#39;off&#39;) removeEventListener() &#125; &#125;, [source]); 通过第二个参数，我们便可模拟出几个常用的生命周期: componentDidMount: 传入[]时，就只会在初始化时调用一次const useMount &#x3D; (fn) &#x3D;&gt; useEffect(fn, []) componentWillUnmount: 传入[]，回调中的返回的函数也只会被最终执行一次const useUnmount &#x3D; (fn) &#x3D;&gt; useEffect(() &#x3D;&gt; fn, []) mounted: 可以使用 useState 封装成一个高度可复用的 mounted 状态；const useMounted &#x3D; () &#x3D;&gt; &#123; const [mounted, setMounted] &#x3D; useState(false); useEffect(() &#x3D;&gt; &#123; !mounted &amp;&amp; setMounted(true); return () &#x3D;&gt; setMounted(false); &#125;, []); return mounted; &#125; componentDidUpdate: useEffect每次均会执行，其实就是排除了 DidMount 后即可；const mounted &#x3D; useMounted() useEffect(() &#x3D;&gt; &#123; mounted &amp;&amp; fn() &#125;) 其它内置钩子: useContext: 获取 context 对象 useReducer: 类似于 Redux 思想的实现，但其并不足以替代 Redux，可以理解成一个组件内部的 redux: 并不是持久化存储，会随着组件被销毁而销毁； 属于组件内部，各个组件是相互隔离的，单纯用它并无法共享数据； 配合useContext&#96;的全局性，可以完成一个轻量级的 Redux；(easy-peasy) useCallback: 缓存回调函数，避免传入的回调每次都是新的函数实例而导致依赖组件重新渲染，具有性能优化的效果； useMemo: 用于缓存传入的 props，避免依赖的组件每次都重新渲染； useRef: 获取组件的真实节点； useLayoutEffect DOM更新同步钩子。用法与useEffect类似，只是区别于执行时间点的不同 useEffect属于异步执行，并不会等待 DOM 真正渲染后执行，而useLayoutEffect则会真正渲染后才触发； 可以获取更新后的 state； 自定义钩子(useXxxxx): 基于 Hooks 可以引用其它 Hooks 这个特性，我们可以编写自定义钩子，如上面的useMounted。又例如，我们需要每个页面自定义标题: function useTitle(title) &#123; useEffect( () &#x3D;&gt; &#123; document.title &#x3D; title; &#125;); &#125; &#x2F;&#x2F; 使用: function Home() &#123; const title &#x3D; &#39;我是首页&#39; useTitle(title) return ( &lt;div&gt;&#123;title&#125;&lt;&#x2F;div&gt; ) &#125; React Hooks 的限制","categories":[{"name":"React","slug":"React","permalink":"http://example.com/categories/React/"}],"tags":[]},{"title":"ReactDiff算法","slug":"React/ReactDiff算法","date":"2020-07-09T14:48:35.000Z","updated":"2022-05-09T14:52:53.109Z","comments":true,"path":"2020/07/09/React/ReactDiff算法/","link":"","permalink":"http://example.com/2020/07/09/React/ReactDiff%E7%AE%97%E6%B3%95/","excerpt":"","text":"diff算法是怎么运作每一种节点类型有自己的属性，也就是prop，每次进行diff的时候，react会先比较该节点类型 ，假如节点类型不一样，那么react会直接删除该节点，然后直接创建新的节点插入到其中，假如 节点类型一样，那么会比较prop是否有更新，假如有prop不一样，那么react会判定该节点有更新 ，那么重渲染该节点，然后在对其子节点进行比较，一层一层往下，直到没有子节点 把树形结构按照层级分解，只比较同级元素。 给列表结构的每个单元添加唯一的key属性，方便比较。 React 只会匹配相同 class 的 component（这里面的class指的是组件的名字） 合并操作，调用 component 的 setState 方法的时候, React 将其标记为 - dirty.到每一个事件循环结束, React 检查所有标记 dirty的 component重新绘制. 选择性子树渲染。开发人员可以重写shouldComponentUpdate提高diff的性能 优化为了降低算法复杂度，React的diff会预设三个限制： 只对同级元素进行Diff。如果一个DOM节点在前后两次更新中跨越了层级，那么React不会尝试复用他。 两个不同类型的元素会产生出不同的树。如果元素由div变为p，React会销毁div及其子孙节点，并新建p及其子孙节点。 开发者可以通过 key prop来暗示哪些子元素在不同的渲染下能保持稳定 Diff的思路 判断当前节点的更新属于哪种情况 如果是新增，执行新增逻辑 如果是删除，执行删除逻辑 如果是更新，执行更新逻辑 按这个方案，其实有个隐含的前提——不同操作的优先级是相同的 但是React团队发现，在日常开发中，相较于新增和删除，更新组件发生的频率更高。所以Diff会优先判断当前节点是否属于更新 基于以上原因，Diff算法的整体逻辑会经历两轮遍历： 第一轮遍历：处理更新的节点。第二轮遍历：处理剩下的不属于更新的节点。 diff算法的作用计算出Virtual DOM中真正变化的部分，并只针对该部分进行原生DOM操作，而非重新渲染整个页面。 传统diff算法通过循环递归对节点进行依次对比，算法复杂度达到 O(n^3) ，n是树的节点数，这个有多可怕呢？——如果要展示1000个节点，得执行上亿次比较。。即便是CPU快能执行30亿条命令，也很难在一秒内计算出差异。","categories":[{"name":"React","slug":"React","permalink":"http://example.com/categories/React/"}],"tags":[]},{"title":"json和xml数据的区别是什么？","slug":"javascript/json和xml数据的区别是什么？","date":"2020-06-28T05:49:47.000Z","updated":"2022-04-28T06:02:02.001Z","comments":true,"path":"2020/06/28/javascript/json和xml数据的区别是什么？/","link":"","permalink":"http://example.com/2020/06/28/javascript/json%E5%92%8Cxml%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"","text":"json和xml数据的区别是什么? 数据体积方面: xml是重量级的 json是轻量级的，传递的速度更快些。 数据传输方面: xml在传输过程中比较占带宽 json占带宽少,易于压缩。 数据交互方面: json于javascript的交互更加方便，更容易解析处理，更好的进行数据交互。 xml和json都用于项目交互下，xml多用于做配置文件，json用于数据交互。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[]},{"title":"React中的类组件和函数组件的区别","slug":"React/React中的类组件和函数组件的区别","date":"2020-04-10T01:12:04.000Z","updated":"2022-05-03T01:54:31.343Z","comments":true,"path":"2020/04/10/React/React中的类组件和函数组件的区别/","link":"","permalink":"http://example.com/2020/04/10/React/React%E4%B8%AD%E7%9A%84%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"React中的类组件和函数组件之间有什么区别？类组件(class components) 无论是使用函数或者类来声明一个组件，它绝不能修改组件的props。 所有React组件都必须是纯函数，并禁止修改自身的props。 React是单项数据流，父组件改变了属性，那么子组件视图会更新。 属性props是外界传递过来的，状态state是组件本身的，状态可以在组件中任意修改 组件的属性和状态改变都会更新视图。 class Welcome extends React.Component &#123; render() &#123; return ( &lt; h1 &gt; Welcome &#123; this.props.name &#125; &lt; &#x2F;h1&gt;);&#125;&#125;ReactDOM.render(&lt;Welcomename&#x3D;&#39;react&#39;&#x2F; &gt; , document.getElementById(&#39;root&#39;)); 函数组件（functional component）函数组件接受一个单一的props对象并返回了一个React元素 function Welcome(props) &#123; return &lt;h1 &gt; Welcome &#123; props.name &#125; &lt; &#x2F;h1&gt;&#125;ReactDOM.render(&lt;Welcomename&#x3D;&#39;react&#39;&#x2F; &gt; , document.getElementById(&#39;root&#39;)); 区别语法上区别两者最明显的不同就是在语法上，函数组件是一个纯函数，它接受一个props对象返回一个react元素。而类组件需要继承React.Component并且创建render函数返回react元素,这将会要更多的代码，虽然它们实现的效果相同。 状态管理因为函数组件是一个纯函数，你不能在组件中使用setState()，这也是为什么把函数组件称作为无状态组件如果你需要在你的组件中使用state，可以选择创建一个类组件或者将state提升到你的父组件中，然后通过props对象传递到子组件 声明周期钩子你不能再函数组件中使用声明周期钩子，原因和不能使用state一样，所有的生命周期钩子都来自于继承React.Component中因此，如果你想使用声明周期钩子，那么需要使用类组件 注意: 在react16.8版本添加了hooks，使得我们可以在函数组件中使用useState钩子去管理state，使用useEffect钩子去使用声明周期函数因此，2,3两点不是他们的区别点，从这个改版中我们可以看出作者更看重函数组件，而且react团队曾提及到在react之后的版本将会对函数组件的性能方面进行提升","categories":[{"name":"React","slug":"React","permalink":"http://example.com/categories/React/"}],"tags":[]},{"title":"react组件通信方式","slug":"React/react组件通信方式","date":"2020-04-06T05:57:52.000Z","updated":"2022-05-03T01:08:41.373Z","comments":true,"path":"2020/04/06/React/react组件通信方式/","link":"","permalink":"http://example.com/2020/04/06/React/react%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/","excerpt":"","text":"react组件通信的方式 父组件向子组件通讯： 父组件可以向子组件通过传入props的方式，向子组件进行通讯 子组件向父组件通讯: props + 回调的方式，父组件向子组件传递props进行通讯，此props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息作为参数，传递到父组件的作用域中 兄弟组件通信: 找到这两兄弟的节点共同的父节点，结合上面两种方式由父节点转发信息进行通讯 跨层级通信: context设计的目的是为了共享那些对于一个组件树而言是’全局’的数据，例如当前认证的用户、主题或者首选语言，对于跨层的全局数据通过Context通信再合适不过 发布订阅模式： 发布者发布事件，订阅者监听事件并做出反应，我们可以通过引入event模块进行通讯 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信，这种工具会维护一个全局状态中心Store，并根据不同的事件产生新的状态","categories":[{"name":"React","slug":"React","permalink":"http://example.com/categories/React/"}],"tags":[]},{"title":"redux原理","slug":"React/redux原理","date":"2020-04-03T00:19:29.000Z","updated":"2022-05-03T00:47:35.344Z","comments":true,"path":"2020/04/03/React/redux原理/","link":"","permalink":"http://example.com/2020/04/03/React/redux%E5%8E%9F%E7%90%86/","excerpt":"","text":"redux原理**Redux:**Redux是当今最热门的前端开发库之一.它是javascript程序的可预测状态容器，用于整个应用的状态管理.使用Redux开发的应用易于测试，可以在不同的环境中运行，并显示一致的行为。 数据如何通过Redux流动？ 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。 然后，Store自动调用Reducer，并且传入两个参数：当前State和Action，Reducer会返回新的State State一旦发生变化，Store就会调用监听函数,来更新View。 Redux遵循的三个原则是什么？ 单一事实来源:整个应用的状态存储在单个store中的对象&#x2F;状态树里，单一状态树可以更容易地跟踪时间变化，并调试或检查应用程序. 状态是只读的:改变状态的唯一方法是触发一个动作。动作是描述变化的普通js对象，就像state是数据最小的表示一样，该操作是对数据更改的最小表示。 使用纯函数进行更改:为了指定状态树如果通过操作进行转化，你需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。 你对”单一事实来源”有什么理解？Redux使用”Store”将程序的整个状态存储在同一个地方。因此所有的组件状态都存储在Store中，并且它从Store本身接受更新.单一状态树可以更容易地跟踪时间的变化，并调试或检查程序。 Redux组成: Action 用于描述发生了什么事情的对象 Reducer 这是一个确定状态将如何变化的地方 Store 整个程序的状态&#x2F;对象树保存在Store中 view 只显示Store提供的数据 如何在Redux中定义Action？react中的Action必须具有type属性，该属性指示正在执行的ACTION的类型。必须将他们定义为字符串常量，并且还可以向其添加更多的属性。 redux中，Action被名为Action Creators的函数所创建,以下是Action和Action Creator的示例： function addTodo（text）&#123; return &#123; type:ADD_TODO, text &#125; &#125; 解释Reducer的作用Reducers是纯函数,它规定应用程序的状态怎样因响应ACTION而改变。reducers通过接受先前的状态和action来工作,然后它返回一个新的状态。它根据操作的类型确定需要执行哪种更新，然后返回新的值，如果不需要完成任务，它会返回原来的状态。 Store在Redux中的意义是什么？Store是一个javascript对象,它可以保存程序的状态，并提供一些方法来访问状态、调度操作和注册侦听器.应用程序的整个状态&#x2F;对象树保存在单一存储中。因此，redux非常简单且是可预测的。我们可以将中间件传递到Store来处理数据,并记录改变存储状态的各种操作。所有操作都通过reducer返回一个新的状态。 redux有哪些优点? 结果的可预测性 - 由于总是存在一个真实来源，即store，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。 可维护性 - 代码变得更容易维护，具有可预测的结果和严格的结构。 服务器端渲染 - 你只需将服务器上创建的store传到客户端即可。这对初始化渲染非常有用，并且可以优化应用性能，从而提供更好的用户体验。 开发人员管理 - 从操作到状态更改，开发人员可以实时跟踪应用中发生的所有事情。 社区和生态系统 - Redux背后有一个巨大的社区，这使得它更加迷人。一个由才华横溢的人组成的大型社区为库的改进作出了贡献，并开发了各种应用。 易于测试 - Redux的代码主要是小巧，纯粹和独立的功能。这使代码可测试且独立。 组织 - Redux准确地说明了代码的组织方式，这使得代码在团队使用更加一致和简单。","categories":[{"name":"React","slug":"React","permalink":"http://example.com/categories/React/"}],"tags":[]},{"title":"js排序的几种方法","slug":"javascript/js排序的几种方法","date":"2020-03-28T07:14:20.000Z","updated":"2022-04-28T07:19:50.279Z","comments":true,"path":"2020/03/28/javascript/js排序的几种方法/","link":"","permalink":"http://example.com/2020/03/28/javascript/js%E6%8E%92%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"– js排序的几种方法 sort（）排序 var ar1&#x3D;[2,4,6,8,1,3] var ar2&#x3D;[2,16,36,8,56] ar1.sort() ar2.sort() &#x2F;&#x2F;这个方法值只能排序第一位数 也可以字符串进行排序 console.log(ar1) &#x2F;&#x2F;[1,2,3,4,6,8] console.log(ar2) &#x2F;&#x2F;[16, 2, 36, 56, 8] ar2.sort(function(a,b)&#123; return a-b &#x2F;&#x2F;a-b为升序 &#x2F;&#x2F;return b-a &#x2F;&#x2F;b-a为降序 &#125;) console.log(ar2)&#x2F;&#x2F;[2, 8, 16, 36, 56] reverse()方法 var ar1&#x3D;[2,4,6,8,1,3] ar1.reverse() &#x2F;&#x2F;此方法为倒序，也就是反过来。并不会进行大小排序 console.log(ar1) &#x2F;&#x2F;[3, 1, 8, 6, 4, 2] 冒泡排序 &#x2F;每轮依次比较相邻两个数的大小，后面比前面小则交换 var b&#x3D;0&#x2F;&#x2F;设置用来调换位置的值 var a&#x3D;[1,9,33,2,5,34,23,98,14] &#x2F;&#x2F;冒泡排序 for(var i&#x3D;0;i&lt;a.length;i++)&#123; for(var j&#x3D;0;j&lt;a.length;j++)&#123; if(a[j]&gt;a[j+1])&#123; b&#x3D;a[j] a[j]&#x3D;a[j+1] a[j+1]&#x3D;b &#125; &#125; &#125; console.log(a)&#x2F;&#x2F;[1, 2, 5, 9, 14, 23, 33, 34, 98] 选择排序 通过比较首先选出最小的数放在第一个位置上，然后在其余的数中选出次小数放在第二个位置上,依此类推,直到所有的数成为有序序列。 var arr &#x3D; [9, 8, 7, 6, 5, 4]; &#x2F;&#x2F;用选择排序的方法从小到大排列数组元素。 &#x2F;&#x2F;比较的轮数 for(var i &#x3D; 0; i &lt; arr.length - 1; i++)&#123; &#x2F;&#x2F;每轮比较的次数 for(var j &#x3D; i + 1; j &lt; arr.length; j++)&#123; if(arr[i] &gt; arr[j])&#123; var tmp &#x3D; arr[i]; arr[i] &#x3D; arr[j]; arr[j] &#x3D; tmp; &#125; &#125; &#125; alert(arr);&#x2F;&#x2F;4,5,6,7,8,9 快速排序先从数列中取出一个数作为基准数分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边再对左右区间重复第二步，直到各区间只有一个数 function quickSort(arr, i, j) &#123; if(i &lt; j) &#123; let left &#x3D; i; let right &#x3D; j; let mid &#x3D; Math.floor((left+right)&#x2F;2); let temp &#x3D; arr[left]; arr[left] &#x3D; arr[mid]; arr[mid] &#x3D; temp; let pivot &#x3D; arr[left]; while(i &lt; j) &#123; while(arr[j] &gt;&#x3D; pivot &amp;&amp; i &lt; j) &#123; &#x2F;&#x2F; 从后往前找比基准小的数 j--; &#125; if(i &lt; j) &#123; arr[i++] &#x3D; arr[j]; &#125; while(arr[i] &lt;&#x3D; pivot &amp;&amp; i &lt; j) &#123; &#x2F;&#x2F; 从前往后找比基准大的数 i++; &#125; if(i &lt; j) &#123; arr[j--] &#x3D; arr[i]; &#125; &#125; arr[i] &#x3D; pivot; quickSort(arr, left, i-1); quickSort(arr, i+1, right); return arr; &#125; &#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[]},{"title":"React声明周期","slug":"React/React声明周期","date":"2020-03-09T07:30:35.000Z","updated":"2022-05-09T07:39:09.033Z","comments":true,"path":"2020/03/09/React/React声明周期/","link":"","permalink":"http://example.com/2020/03/09/React/React%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F/","excerpt":"","text":"react 旧版生命周期 主要可分为 初始化阶段、挂载阶段、更新阶段、卸载阶段。 初始化阶段发生在 constructor 中的内容，在 constructor 中进行 state、props 的初始化，在这个阶段修改 state，不会执行更新阶段的生命周期，可以直接对 state 赋值。 挂载阶段 对应的生命周期为： componentWillMount 发生在 render 函数之前，还没有挂载 Dom render componentDidMount 发生在 render 函数之后，已经挂载 Dom 更新阶段更新阶段分为由 state 更新引起和 props 更新引起 * props * 1. componentWillReceiveProps(nextProps,nextState) 这个生命周期主要为我们提供对 props 发生改变的监听，如果你需要在 props 发生改变后，相应改变组件的一些 state。在这个方法中改变 state 不会二次渲染，而是直接合并 state。 * 2. shouldComponentUpdate(nextProps,nextState) 这个生命周期需要返回一个 Boolean 类型的值，判断是否需要更新渲染组件，优化 react 应用的主要手段之一，当返回 false 就不会再向下执行生命周期了，在这个阶段不可以 setState()，会导致循环调用。 * 3. componentWillUpdate(nextProps,nextState) 这个生命周期主要是给我们一个时机能够处理一些在 Dom 发生更新之前的事情，如获得 Dom 更新前某些元素的坐标、大小等，在这个阶段不可以 setState()，会导致循环调用。 **一直到这里 this.props 和 this.state 都还未发生更新** * 4. render 执行 render 函数。 * 5. componentDidUpdate(prevProps, prevState) 在此时已经完成渲染，Dom 已经发生变化，State 已经发生更新，prevProps、prevState 均为上一个状态的值。 * state（具体同上） * 1. shouldComponentUpdate * 2. componentWillUpdate * 3. render * 4. componentDidUpdate 卸载阶段 componentWillUnmount componentWillUnmount 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount 中创建的订阅等。componentWillUnmount 中不应调用 setState，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。 React 新版生命周期React 16 中删除了如下三个生命周期。 componentWillMount componentWillReceiveProps componentWillUpdate 官方给出的解释是 react 打算在17版本推出新的 Async Rendering，提出一种可被打断的生命周期，而可以被打断的阶段正是实际 dom 挂载之前的虚拟 dom 构建阶段，也就是要被去掉的三个生命周期。本身这三个生命周期所表达的含义是没有问题的，但 react 官方认为我们（开发者）也许在这三个函数中编写了有副作用的代码，所以要替换掉这三个生命周期，因为这三个生命周期可能在一次 render 中被反复调用多次 取代这三个生命周期的是两个新生命周期static getDerivedStateFromProps(nextProps,nextState)在 React 16.3.0 版本中：在组件实例化、接收到新的 props 时会被调用在 React 16.4.0 版本中：在组件实例化、接收到新的 props 、组件状态更新时会被调用 方法可以返回一个对象，将会和 state 发生合并，且不会触发 re-render。 这个生命周期主要为我们提供了一个可以在组件实例化或 props、state 发生变化后根据 props 修改 state 的一个时机，用来替代旧的生命周期中的 componentWillMount、ComponentWillReceiveProps。因为是一个静态方法，this 指向不是组件实例。 getSnapshotBeforeUpdate（prevProps,prevState） 在 render 函数调用之后，实际的 Dom 渲染之前，在这个阶段我们可以拿到上一个状态 Dom 元素的坐标、大小的等相关信息。用于替代旧的生命周期中的 componentWillUpdate。该函数的返回值将会作为 componentDidUpdate 的第三个参数出现","categories":[{"name":"React","slug":"React","permalink":"http://example.com/categories/React/"}],"tags":[]},{"title":"This指向问题","slug":"javascript/This指向问题","date":"2020-02-05T02:33:23.000Z","updated":"2022-05-09T06:28:58.253Z","comments":true,"path":"2020/02/05/javascript/This指向问题/","link":"","permalink":"http://example.com/2020/02/05/javascript/This%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/","excerpt":"","text":"不同情况的调用，this指向分别如何。顺带可以提一下 es6 中箭头函数没有 this, arguments, super 等，这些只依赖包含箭头函数最接近的函数 函数执行改变this由于 JS 的设计原理: 在函数中，可以引用运行环境中的变量。因此就需要一个机制来让我们可以在函数体内部获取当前的运行环境，这便是this 因此要明白 this 指向，其实就是要搞清楚 函数的运行环境，说人话就是，谁调用了函数。例如 obj.fn()，便是 obj 调用了函数，既函数中的 this &#x3D;&#x3D;&#x3D; obj fn()，这里可以看成 window.fn()，因此 this &#x3D;&#x3D;&#x3D; window 但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改 this 的指向: call: fn.call(target, 1, 2) apply: fn.apply(target, [1, 2]) bind: fn.bind(target)(1,2) apply&#x2F;call&#x2F;bind 原理 all、apply 和 bind 是挂在 Function 对象上的三个方法，调用这三个方法的必须是一个函数 func.call(thisArg, param1, param2, ...) func.apply(thisArg, [param1,param2,...]) func.bind(thisArg, param1, param2, ...) 在浏览器里，在全局范围内this 指向window对象；在函数中，this永远指向最后调用他的那个对象；构造函数中，this指向new出来的那个新的对象；apply、call、bind都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[]},{"title":"HTTP状态码及含义","slug":"浏览器/HTTP状态码及含义","date":"2020-01-09T06:39:01.000Z","updated":"2022-05-09T06:45:52.799Z","comments":true,"path":"2020/01/09/浏览器/HTTP状态码及含义/","link":"","permalink":"http://example.com/2020/01/09/%E6%B5%8F%E8%A7%88%E5%99%A8/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%8F%8A%E5%90%AB%E4%B9%89/","excerpt":"","text":"HTTP状态码 1XX：信息状态码 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 2XX：成功状态码 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 3XX：重定向 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 4XX：客户端错误 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 5XX: 服务器错误 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[]}],"categories":[{"name":"React","slug":"React","permalink":"http://example.com/categories/React/"},{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"},{"name":"前端工程化","slug":"前端工程化","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[]}