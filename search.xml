<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>事件循环和宏任务微任务</title>
      <link href="/2022/04/27/%E5%AE%8F%E9%98%9F%E5%88%97%E5%92%8C%E5%BE%AE%E9%98%9F%E5%88%97%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
      <url>/2022/04/27/%E5%AE%8F%E9%98%9F%E5%88%97%E5%92%8C%E5%BE%AE%E9%98%9F%E5%88%97%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>–</p><h2 id="事件循环-宏任务和微任务"><a href="#事件循环-宏任务和微任务" class="headerlink" title="事件循环 宏任务和微任务"></a>事件循环 宏任务和微任务</h2><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><ol><li>js引擎首先必须先执行所有的初始化同步任务代码,遇到异步任务，提交给’异步进程处理’,主线程执行栈会不停监听消息队列是否有异步任务，称位事件循环</li><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ol><p><img src="/2022/04/27/%E5%AE%8F%E9%98%9F%E5%88%97%E5%92%8C%E5%BE%AE%E9%98%9F%E5%88%97%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/1.png"></p><ul><li><strong>宏队列</strong>:<ul><li>用于保存待执行的宏任务（回调）,比如：定时器回调，DOM事件回调,ajax回调</li></ul></li><li><strong>微队列</strong>:<ul><li>用来保存待执行的微任务（回调）,比如：promise的回调，MutationObserver的回调</li></ul></li><li>每次准备取出第一个宏任务执行前，都要将所有的微任务一个一个取出来执行，也就是微任务比宏任务先执行</li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack_优化</title>
      <link href="/2022/04/22/webpack-%E4%BC%98%E5%8C%96/"/>
      <url>/2022/04/22/webpack-%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="1、-如何提高webpack的构建速度？"><a href="#1、-如何提高webpack的构建速度？" class="headerlink" title="1、 如何提高webpack的构建速度？"></a>1、 如何提高webpack的构建速度？</h2><ul><li>多入口情况下，使用CommonsChunkPlugin来提取公共代码</li><li>通过externals配置来提取常用库</li><li>利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。</li><li>使用Happypack 实现多线程加速编译</li><li>使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度</li><li>使用Tree-shaking和Scope Hoisting来剔除多余代码</li></ul><h2 id="2、-如何利用webpack来优化前端性能？（提高性能和体验）"><a href="#2、-如何利用webpack来优化前端性能？（提高性能和体验）" class="headerlink" title="2、 如何利用webpack来优化前端性能？（提高性能和体验）!"></a>2、 如何利用webpack来优化前端性能？（提高性能和体验）!</h2><p>用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。</p><ul><li>压缩代码<ul><li>删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css</li></ul></li><li>利用CDN加速<ul><li>在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径</li></ul></li><li>删除死代码<ul><li>将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数–optimize-minimize来实现</li></ul></li><li>提取公共代码<ul><li>异步组件    — 异步图片   — 配置webpack对小图片打包成base64字符  减少io请求</li></ul></li></ul><h2 id="3、-怎么配置单页应用？怎么配置多页应用？"><a href="#3、-怎么配置单页应用？怎么配置多页应用？" class="headerlink" title="3、 怎么配置单页应用？怎么配置多页应用？"></a>3、 怎么配置单页应用？怎么配置多页应用？</h2><ul><li>单页应用<ul><li>可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可</li></ul></li><li>多页应用<ul><li>可以使用webpack的 AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。</li></ul></li></ul><h2 id="4、-如何提升webpack的运行速度-开发环境-有哪些策略？"><a href="#4、-如何提升webpack的运行速度-开发环境-有哪些策略？" class="headerlink" title="4、 如何提升webpack的运行速度(开发环境) ,有哪些策略？"></a>4、 如何提升webpack的运行速度(开发环境) ,有哪些策略？</h2><ul><li><p>多入口情况下，使用CommonsChunkPlugin来提取公共代码</p></li><li><p>通过externals配置来提取常用库</p></li><li><p>利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。</p></li><li><p>使用Happypack 实现多线程加速编译</p></li><li><p>使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度</p></li><li><p>使用Tree-shaking和Scope Hoisting来剔除多余代码</p></li><li><p>JS代码压缩</p><ul><li>terser是一个JavaScript的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让bundle更小。在production模式下，webpack 默认就是使用 TerserPlugin 来处理我们的代码的。</li><li>TerserPlugin常用的属性如下： - extractComments：默认值为true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释 - parallel：使用多进程并发运行提高构建的速度，默认值是true，并发运行的默认数量： os.cpus().length - 1 - terserOptions：设置我们的terser相关的配置： compress：设置压缩相关的选项，mangle：设置丑化相关的选项，可以直接设置为true mangle：设置丑化相关的选项，可以直接设置为true toplevel：底层变量是否进行转换keep_classnames：保留类的名称 keep_fnames：保留函数的名称</li></ul></li><li><p>代码压缩</p><ul><li>cssCSS压缩通常用于去除无用的空格等，不过因为很难去修改选择器、属性的名称、值等，所以我们可以使用另外一个插件：css-minimizer-webpack-plugin</li></ul></li><li><p>Html文件代码压缩</p></li><li><p>文件大小压缩</p><ul><li>对文件的大小进行压缩，可以有效减少http传输过程中宽带的损耗，文件压缩需要用到 compression-webpack-plugin插件</li></ul></li><li><p>图片压缩</p><ul><li>如果我们对bundle包进行分析，会发现图片等多媒体文件的大小是远远要比 js、css 文件要大的，所以图片压缩在打包方面也是很重要的</li></ul></li><li><p>Tree Shaking</p><ul><li>Tree Shaking 是一个术语，在计算机中表示消除死代码，依赖于ES Module的静态语法分析。在webpack实现Trss shaking有两种不同的方案： usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的 sideEffects：跳过整个模块&#x2F;文件，直接查看该文件是否有副作用</li><li>usedExports的配置方法很简单，只需要将usedExports设为true即可，如下。而sideEffects则用于告知webpack compiler在编译时哪些模块有副作用，配置方法是在package.json中设置sideEffects属性。如果sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports，如果有些文件需要保留，可以设置为数组的形式。</li></ul></li><li><p>代码分离</p></li><li><ul><li>默认情况下，所有的JavaScript代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载， 就会影响首页的加载速度。如果可以分出出更小的bundle，以及控制资源加载优先级，从而优化加载性能。</li></ul></li><li><ul><li>代码分离可以通过splitChunksPlugin来实现，该插件webpack已经默认安装和集成，只需要配置即可。</li></ul></li><li><ul><li>splitChunks有如下几个属性： Chunks：对同步代码还是异步代码进行处理 minSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分 maxSize： 将大于maxSize的包，拆分为不小于minSize的包 minChunks：被引入的次数，默认是1</li></ul></li><li><p>内联 chunk</p></li><li><ul><li>可以通过InlineChunkHtmlPlugin插件将一些chunk的模块内联到html，如runtime的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大但是必须加载的，比如：总结一下，Webpack对前端性能的优化，主要是通过文件体积大小入手，主要的措施有分包、减少Http请求次数等。</li></ul></li></ul><h2 id="5、-npm打包时需要注意哪些？如何利用webpack来更好的构建？"><a href="#5、-npm打包时需要注意哪些？如何利用webpack来更好的构建？" class="headerlink" title="5、 npm打包时需要注意哪些？如何利用webpack来更好的构建？"></a>5、 npm打包时需要注意哪些？如何利用webpack来更好的构建？</h2><pre class="language-none"><code class="language-none">Npm是目前最大的 JavaScript 模块仓库，里面有来自全世界开发者上传的可复用模块。你可能只是JS模块的使用者，但是有些情况你也会去选择上传自己开发的模块。关于NPM模块上传的方法可以去官网上进行学习，这里只讲解如何利用webpack来构建。NPM模块需要注意以下问题：要支持CommonJS模块化规范，所以要求打包后的最后结果也遵守该规则。Npm模块使用者的环境是不确定的，很有可能并不支持ES6，所以打包的最后结果应该是采用ES5编写的。并且如果ES5是经过转换的，请最好连同SourceMap一同上传。Npm包大小应该是尽量小（有些仓库会限制包大小）发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。UI组件类的模块应该将依赖的其它资源文件，例如.css文件也需要包含在发布的模块里。</code></pre><h2 id="6、-什么是长缓存？在webpack中如何做到长缓存优化？"><a href="#6、-什么是长缓存？在webpack中如何做到长缓存优化？" class="headerlink" title="6、 什么是长缓存？在webpack中如何做到长缓存优化？"></a>6、 什么是长缓存？在webpack中如何做到长缓存优化？</h2><ul><li>浏览器在用户访问页面的时候，为了加快加载速度，会对用户访问的静态资源进行存储，但是每一次代码升级或者更新，都需要浏览器去下载新的代码，最方便和最简单的更新方式就是引入新的文件名称。</li><li>在webpack中，可以在output给出输出的文件制定chunkhash，并且分离经常更新的代码和框架代码，通过NameModulesPlugin或者HashedModulesPlugin使再次打包文件名不变。</li></ul><h2 id="7、-在项目中tree-shaking摇树不是很干净，有什么解决方案？"><a href="#7、-在项目中tree-shaking摇树不是很干净，有什么解决方案？" class="headerlink" title="7、 在项目中tree-shaking摇树不是很干净，有什么解决方案？"></a>7、 在项目中tree-shaking摇树不是很干净，有什么解决方案？</h2><ul><li>在webpack.config.js中通过</li><li>来进行tree-shaking 但是单单指定这一个配置  不是很干净</li><li>有些模块导入，只要被引入，</li><li>就会对应用程序产生重要的影响。一个很好的例子就是全局样式表，或者设置全局配置的JavaScript 文件。</li></ul><h2 id="8、-怎么提高webpack的打包效率？"><a href="#8、-怎么提高webpack的打包效率？" class="headerlink" title="8、 怎么提高webpack的打包效率？"></a>8、 怎么提高webpack的打包效率？</h2><ul><li>开发环境优化<ul><li><ol><li>开启热模块替换（HMR）</li></ol></li><li><ol start="2"><li>使用 source-map 进行源代码映射</li></ol></li><li><ol start="3"><li>将只需要被loader执行一次的规则放到 oneOf 里面去</li></ol></li></ul></li><li>生产环境优化<ul><li><ol><li>对资源进行缓存</li></ol></li><li><ol start="2"><li>使用tree shaking（树摇）</li></ol></li><li><ol start="3"><li>使用code split 进行代码分割</li></ol></li><li><ol start="4"><li>文件懒加载和预加载</li></ol></li><li><ol start="5"><li>多进程打包</li></ol></li><li><ol start="6"><li>使用PWA（离线加载）</li></ol></li><li><ol start="7"><li>使用externals 忽略某些包，然后通过cdn引入</li></ol></li><li><ol start="8"><li>使用dll 技术对某些库（第三方库）进行单独打包</li></ol></li></ul></li></ul><h2 id="9、-按需加载的原理"><a href="#9、-按需加载的原理" class="headerlink" title="9、 按需加载的原理"></a>9、 按需加载的原理</h2><ul><li>使用符合ECMAScript 提案的import()语法</li><li>使用 webpack 特定的require.ensure</li></ul><h2 id="10、-预获取-x2F-预加载模块"><a href="#10、-预获取-x2F-预加载模块" class="headerlink" title="10、 预获取&#x2F;预加载模块"></a>10、 预获取&#x2F;预加载模块</h2><pre class="language-none"><code class="language-none">Webpack v4.6.0+ 增加了对预获取和预加载的支持。在声明 import 时，使用下面这些内置指令，可以让 webpack 输出 &quot;resource hint(资源提示)&quot;，来告知浏览器●  prefetch(预获取)：将来某些导航下可能需要的资源● preload(预加载)：当前导航下可能需要资源添加第二句魔法注释： webpackPrefetch: true告诉 webpack 执行预获取。这会生成 &lt;link rel&#x3D;&quot;prefetch&quot; href&#x3D;&quot;math.js&quot;&gt;       并追加到页面头部，指示着浏览器在闲置时间预取 math.js 文件。</code></pre><h2 id="12-什么是Tree-sharking"><a href="#12-什么是Tree-sharking" class="headerlink" title="12.  什么是Tree-sharking?"></a>12.  什么是Tree-sharking?</h2><ul><li>Tree是树，sharking是摇晃的意思。那么树摇晃的时候，肯定会’摇’下来一些无用的叶子。从编程的角度思考，如果假设我们的代码是一棵树（Tree），那么摇下来的无用的的叶子是什么呢？当然是无用的代码啦，他有个专业的术语，叫做dead-code（死码）</li><li>指打包中去除那些引入了但在代码中没用到的死代码。在wepack中js treeshaking通过UglifyJsPlugin来进行，css中通过purify-CSS来进行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack5_Loader</title>
      <link href="/2022/04/21/webpack-Loader/"/>
      <url>/2022/04/21/webpack-Loader/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack-Loader整理"><a href="#webpack-Loader整理" class="headerlink" title="webpack Loader整理"></a>webpack Loader整理</h1><h2 id="1-Loader机制的作用是什么？"><a href="#1-Loader机制的作用是什么？" class="headerlink" title="1. Loader机制的作用是什么？"></a>1. Loader机制的作用是什么？</h2><ul><li>webpack 本身只能处理 JavaScript 和 JSON 文件，而 loader 为 webpack 添加了处理其他类型文件的能力。</li><li>webpack默认只能打包js文件，配置里的module.rules数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换打包成js。<pre class="language-none"><code class="language-none">注意：use属性的值需要是一个由 Loader 名称组成的数组，Loader 的执行顺序是由后到前的；每一个 Loader 都可以通过 URL querystring 的方式传入参数，例如css-loader?minimize中的minimize告诉css-loader要开启 CSS 压缩。</code></pre></li></ul><h2 id="2-有哪些常见的Loader？他们是解决什么问题的？"><a href="#2-有哪些常见的Loader？他们是解决什么问题的？" class="headerlink" title="2. 有哪些常见的Loader？他们是解决什么问题的？"></a>2. 有哪些常见的Loader？他们是解决什么问题的？</h2><pre class="language-none"><code class="language-none">file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去source-map-loader：加载额外的 Source Map 文件，以方便断点调试image-loader：加载并且压缩图片文件babel-loader：把 ES6 转换成 ES5css-loader：加载 CSS，支持模块化、压缩、文件导入等特性style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。eslint-loader：通过 ESLint 检查 JavaScript 代码</code></pre><h2 id="3-Webpack-的-Loader-是什么？"><a href="#3-Webpack-的-Loader-是什么？" class="headerlink" title="3. Webpack 的 Loader 是什么？"></a>3. Webpack 的 Loader 是什么？</h2><p>Webpack 只能理解 JavaScript 和 JSON 文件，这是 Webpack 开箱可用的自带能力。loader 可以让 Webpack 能够去处理其他类型的文件，chunk 文件以供应用程序使用，以及被添加到依赖图中，也可将内联图像转换为 data URL。简单来说，loader 可以将一段代码转换成另一端代码，通常用来将一段特殊代码转换成一段浏览器可识别的代码。</p><ul><li>loader 有两个属性：<ul><li>test，正则表达式，用于识别出哪些文件会被转换，</li><li>use 定义在进行转换时应该使用哪个<ul><li>loader，可以是字符串、数组和对象。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack5_Plugin</title>
      <link href="/2022/04/21/webpack-Plugin/"/>
      <url>/2022/04/21/webpack-Plugin/</url>
      
        <content type="html"><![CDATA[<p>–</p><h1 id="webpack-Plugin整理"><a href="#webpack-Plugin整理" class="headerlink" title="webpack Plugin整理"></a>webpack Plugin整理</h1><h2 id="1-Plugin（插件）的作用是什么？"><a href="#1-Plugin（插件）的作用是什么？" class="headerlink" title="1. Plugin（插件）的作用是什么？"></a>1. Plugin（插件）的作用是什么？</h2><p>通过安装和配置第三方的插件，可以拓展 webpack 的能力，从而让 webpack 用起来更方便。最常用的webpack 插件有如下两个：</p><ul><li><p>webpack-dev-server</p><ul><li>类似于 node.js 阶段用到的 nodemon 工具每当修改了源代码，webpack 会自动进行项目的打包和构建</li></ul></li><li><p>html-webpack-plugin</p><ul><li>webpack 中的 HTML 插件（类似于一个模板引擎插件）可以通过此插件自定制 index.html 页面的内容</li></ul></li></ul><p><strong>webpack-dev-server 可以让 webpack 监听项目源代码的变化，从而进行自动打包构建。</strong></p><pre class="language-none"><code class="language-none">修改package.json -&gt; scripts中的dev命令：&quot;scripts&quot;:&#123;      &quot;dev&quot;：&quot;webpack serve&quot;，&#x2F;&#x2F; script 节点下的脚本,可以通过 npm run 执行&#125;</code></pre><h2 id="2-有哪些常见的Plugin？他们是解决什么问题的？"><a href="#2-有哪些常见的Plugin？他们是解决什么问题的？" class="headerlink" title="2. 有哪些常见的Plugin？他们是解决什么问题的？"></a>2. 有哪些常见的Plugin？他们是解决什么问题的？</h2><pre class="language-none"><code class="language-none">define-plugin：定义环境变量commons-chunk-plugin：提取公共代码uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码purgecss-webpack-plugin：擦除无用csshappypack：多线程处理打包webpack-bundle-analyzer：打包分析speed-measure-webpack-plugin：构建速度分析html-webpack-plugin：为html文件中引入的外部资源如script、link动态添加每次compile后的hash，防止引用缓存的外部文件问题</code></pre><h2 id="3-Webpack-的-Plugin-是什么？"><a href="#3-Webpack-的-Plugin-是什么？" class="headerlink" title="3. Webpack 的 Plugin 是什么？"></a>3. Webpack 的 Plugin 是什么？</h2><p>plugin是插件的意思，通常是用于对某个现有的架构进行扩展。<br>        &#x3D;&#x3D;&gt; webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等。</p><h2 id="4-Loader和Plugin的不同？"><a href="#4-Loader和Plugin的不同？" class="headerlink" title="4. Loader和Plugin的不同？"></a>4. Loader和Plugin的不同？</h2><h3 id="不同的作用"><a href="#不同的作用" class="headerlink" title="不同的作用"></a>不同的作用</h3><ul><li>Loader直译为”加载器”。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力</li><li>Plugin直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li></ul><h3 id="不同的用法"><a href="#不同的用法" class="headerlink" title="不同的用法"></a>不同的用法</h3><ul><li>Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）</li><li>Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。</li></ul><h3 id="4-描述一下编写loader或plugin的思路？"><a href="#4-描述一下编写loader或plugin的思路？" class="headerlink" title="4.描述一下编写loader或plugin的思路？"></a>4.描述一下编写loader或plugin的思路？</h3><pre class="language-none"><code class="language-none">Loader像一个&quot;翻译官&quot;把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。编写Loader时要遵循单一原则，每个Loader只做一种&quot;转义&quot;工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack整理</title>
      <link href="/2022/04/20/webpack%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/04/20/webpack%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>–</p><h1 id="webpack5概念"><a href="#webpack5概念" class="headerlink" title="webpack5概念"></a>webpack5概念</h1><h2 id="1-谈谈你对Webpack的理解？"><a href="#1-谈谈你对Webpack的理解？" class="headerlink" title="1.谈谈你对Webpack的理解？"></a>1.谈谈你对Webpack的理解？</h2><p>是一个模块化打包工具，将不同的资源和文件，进行打包，合并在一个文件里。</p><pre class="language-none"><code class="language-none">1、依赖管理：方便引用第三方模块，让模块更容易复用、避免全局注入导致的冲突、、避免重复加载或者加载不必要的模块2、合并代码：把各个分散的模块集中打包成大文件，减少HTTP的链接的请求次数，配合uglify.js可以减少、优化代码的体积3、各种插件：babel把ES6+转[webpack5整理]()化为ES5-，eslint可以检查编译时的各种错误</code></pre><h2 id="2-webpack的工作原理"><a href="#2-webpack的工作原理" class="headerlink" title="2.webpack的工作原理?"></a>2.webpack的工作原理?</h2><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><pre class="language-none"><code class="language-none">1. Entry:入口指示webpack以哪个文件为入口起点开始打包，分析构建内部依赖图2. output:输出指示webpack的打包后的资源bundles输出到哪里去，以及如何命名3. Loader:让webpack能够去处理哪些非JavaScrip文件（webpack自身只理解javaScript)4. plugin:插件可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等5. mode:模式指示webpack使用相应模式的配置</code></pre><h4 id="流程概括"><a href="#流程概括" class="headerlink" title="流程概括"></a>流程概括</h4><pre class="language-none"><code class="language-none">webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：1. 初始化参数：从配置文件和Shell语句中读取与合并参数，得出最终的参数；2. 开始编译： 用上一步得到的参数初始化Complier对象，加载所有配置的插件，执行对象的run方法开始执行编译；3. 确定入口： 根据配置中的entry找出所有入口文件；4. 编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理；5. 完成模块编译： 在经过第4步使用Loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及他们之间的依赖关系；6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；7. 输出完成： 在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。在以上过程中，webpack会在特定的时间点广播出特定的时间，插件在监听到感兴趣的时间后会执行特定的逻辑，并且插件可以调用Webpack提供的API改变Webpack的运行结果。</code></pre><h4 id="流程细节"><a href="#流程细节" class="headerlink" title="流程细节"></a>流程细节</h4><ul><li>Webpack的构建流程可以分为以下三个阶段：<ul><li><ol><li>初始化：启动构建，读取与合并配置参数，加载Plugin，实例化Complier.</li></ol></li><li><ol start="2"><li>编译：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件内容，再找到该Module依赖的Module，递归地进行编译处理。</li></ol></li><li><ol start="3"><li>输出： 对编译后的Module组合成Chunk，把Chunk转换成文件，输出到文件系统。</li></ol></li></ul></li></ul><h2 id="3-webpack4和webpack5的区别？"><a href="#3-webpack4和webpack5的区别？" class="headerlink" title="3.webpack4和webpack5的区别？"></a>3.webpack4和webpack5的区别？</h2><pre class="language-none"><code class="language-none">更快的构建速度更高的版本要求更灵活的模块组合更智能的缓存优化更小的体积webpack4 上需要下载安装 terser-webpack-plugin 插件webpack5 内部本身就自带 js 压缩功能，他内置了 terser-webpack-plugin 插件，我们不用再下载安装。而且在 mode&#x3D;“production” 的时候会自动开启 js 压缩功能。webpack4 缓存配置    &#x3D;&#x3D;&gt; npm install hard-source-webpack-plugin -D    webpack5 缓存配置    &#x3D;&#x3D;&gt; webpack5 内部内置了 cache 缓存机制。直接配置即可。    &#x3D;&#x3D;&gt; cache 会在开发模式下被设置成 type： memory 而且会在生产模式把cache 给禁用掉。webpack4 启动服务    &#x3D;&#x3D;&gt; 通过 webpack-dev-server 启动服务 webpack5 启动服务    &#x3D;&#x3D;&gt; 内置使用 webpack serve 启动，但是他的日志不是很好，所以一般都加都喜欢用 webpack-dev-server 优化。打包的区别● webpack4打包:即使后续没有使用到num1的函数，依然会将代码打包进去● webpack5打包:后续没有使用到num1的函数，不会将代码打包进去输出代码的区别● webpack4只能输出es5的代码● webpack5新增属性output.ecmaVersion，可以生成ES5和ES6的代码</code></pre><h2 id="4-前端代码为何要进行构建和打包？"><a href="#4-前端代码为何要进行构建和打包？" class="headerlink" title="4. 前端代码为何要进行构建和打包？"></a>4. 前端代码为何要进行构建和打包？</h2><ul><li><p>代码方面体积更小，加载更快（tree-shaking，压缩合并）</p><ul><li>编译高级语言和语法（ts，es6，模块化）</li><li>兼容性和错误提示（polyfill，postcss，eslint）</li></ul></li><li><p>研发流程统一、高效的开发环境</p><ul><li>统一的构建流程和产出标准</li><li>集成公司构建规范（提测，上线）</li></ul></li></ul><h2 id="5-webpack的优缺点？"><a href="#5-webpack的优缺点？" class="headerlink" title="5. webpack的优缺点？"></a>5. webpack的优缺点？</h2><ol><li>优点<ul><li>webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD&#x2F;CMD 的支持也很全面，方便旧项目进行代码迁移。</li><li>能被模块化的不仅仅是 JS 了。</li><li>开发便捷，能替代部分 grunt&#x2F;gulp 的工作，比如打包、压缩混淆、图片转base64等。</li><li>扩展性强，插件机制完善</li></ul></li><li>缺点<ul><li>配置复杂</li><li>不分包bundle.js体积庞大</li><li>只能用于采用模块化开发的项目</li><li>打包慢</li><li>ES模块除Module外全用babel转换，但是一部分ES2015 语法的 firefox 与 chrome 浏览器中能直接跑的代码，无法用 webpack 编译</li></ul></li></ol><h2 id="6-什么是bundle，什么是chunk，什么是module"><a href="#6-什么是bundle，什么是chunk，什么是module" class="headerlink" title="6. 什么是bundle，什么是chunk，什么是module"></a>6. 什么是bundle，什么是chunk，什么是module</h2><pre class="language-none"><code class="language-none">bundle： 是由webpack打包出来的文件chunk： 是指webpack在进行模块依赖分析的时候，代码分割出来的代码块module： 是开发中的单个模块</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝和浅拷贝</title>
      <link href="/2022/03/21/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2022/03/21/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p><strong>浅拷贝和深拷贝都只针对于引用数据类型</strong></p><ul><li>浅拷贝<ul><li>只复制指向对象的指针,而不复制对象本身，新旧对象还是共享同一块内存;</li></ul></li><li>深拷贝<ul><li>另外创造一个一模一样的对象,新对象跟原对象不共享内存,修改新对象不会影响到原对象</li></ul></li></ul><h3 id="浅拷贝实现方法"><a href="#浅拷贝实现方法" class="headerlink" title="浅拷贝实现方法"></a>浅拷贝实现方法</h3><pre class="language-none"><code class="language-none">1.Object.assign方法var obj &#x3D; &#123;    a:1,    b:2&#125;var obj1 &#x3D; Object.assign(&#123;&#125;,obj)obj1.a &#x3D; 3:console.log(obj.a) &#x2F;&#x2F; 32.解构赋值var obj1 &#x3D; &#123;a: 1, b: 2&#125;var obj2 &#x3D; &#123;...obj1&#125;obj2.a &#x3D; 4console.log(obj1, obj2)</code></pre><h3 id="深拷贝实现方法"><a href="#深拷贝实现方法" class="headerlink" title="深拷贝实现方法"></a>深拷贝实现方法</h3><pre class="language-none"><code class="language-none">1.json.stringify()方法var obj1 &#x3D; [&#123;    name: &#39;臧三&#39;,    childs: [&#39;小明&#39;, &#39;小芳&#39;]&#125;]var obj2 &#x3D; JSON.parse(JSON.stringify(obj1))obj2[0].childs &#x3D; []console.log(obj1, obj2)2.递归方法var obj1 &#x3D; [&#123;    name: &#39;臧三&#39;,    childs: [&#39;小明&#39;, &#39;小芳&#39;],    fn: function() &#123;&#125;,    age: undefined&#125;]var obj2 &#x3D; extend(obj1)obj2[0].childs &#x3D; []console.log(obj1, obj2)function extend(data) &#123;    if (typeof data &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; data) &#123;        let val &#x3D; typeof data.length &#x3D;&#x3D;&#x3D; &#39;number&#39; ? [] : &#123;&#125;        for(let i in data) &#123;            val[i] &#x3D; extend(data[i])        &#125;        return val    &#125; else &#123;        return data    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>闭包的理解</title>
      <link href="/2022/03/14/%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2022/03/14/%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>–</p><h2 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h2><p>一个函数和对其他周围状态的引用捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包</strong>。<br>闭包可以在一个内层函数中访问到外层函数的作用域。</p><h3 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h3><ul><li>可以让外部访问函数内部的变量。</li><li>可以避免使用全局变量。防止全局变量污染。</li><li>可以让局部变量常驻在内存中</li><li>会造成内存泄露(有一个内存空间长期被占用，而不被释放)</li></ul><h3 id="闭包示例"><a href="#闭包示例" class="headerlink" title="闭包示例"></a>闭包示例</h3><pre class="language-none"><code class="language-none"> function fn1()&#123;            var max &#x3D; 10;            return function (x) &#123;                if(x &gt; max)&#123;                    console.log(x);                &#125;            &#125;        &#125;var fn2 &#x3D; fn1();fn2(20);</code></pre>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>防抖与节流</title>
      <link href="/2022/02/27/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
      <url>/2022/02/27/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p><strong>在事件被触发的n秒后再执行回调,如果这n秒又被触发，则重新计时.高频操作下，只执行最后一次.</strong></p><pre class="language-none"><code class="language-none">&lt;script&gt;    &#x2F;&#x2F; 防抖  用户触发事件过于频繁    let inp &#x3D; document.getElementsByTagName(&#39;input&#39;)    inp[0].oninput &#x3D; deco(function () &#123;        console.log(this.value)    &#125;, 500)    function deco(fn, time) &#123;        let t &#x3D; null;        return function () &#123;            if (t) &#123;                clearTimeout(t)            &#125;            t &#x3D; setTimeout(() &#x3D;&gt; &#123;                fn.call(this)            &#125;, time)        &#125;    &#125;&lt;&#x2F;script&gt;</code></pre><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p><strong>一定时间内 控制触发的次数</strong></p><pre class="language-none"><code class="language-none">&lt;script&gt;  window.onscroll &#x3D; fn(function () &#123;        console.log(1111111)    &#125;, 500)    function fn(fn1, time) &#123;        let flag &#x3D; true;        return function () &#123;            if (flag) &#123;                setTimeout(() &#x3D;&gt; &#123;                    fn1.call(this)                    flag &#x3D; true                &#125;, time)            &#125;            flag &#x3D; false;        &#125;    &#125;&lt;&#x2F;script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实现异步的方法</title>
      <link href="/2022/02/21/%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2022/02/21/%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="实现异步的方法"><a href="#实现异步的方法" class="headerlink" title="实现异步的方法"></a>实现异步的方法</h2><ul><li>回调函数(Callback)</li><li>事件监听</li><li>发布订阅</li><li>promise</li><li>生成器(Generators&#x2F;yield)</li><li>async&#x2F;await</li></ul><p><strong>js异步编程进化史: callback –&gt; promise –&gt; generator –&gt;async + await</strong></p><p>async&#x2F;await函数的实现，就是将Generator函数和自动执行器，包装在一个函数里<br>async&#x2F;await 可以说是异步终极解决方案了。</p><h3 id="async-x2F-await-函数相对于Promise-优势体现在："><a href="#async-x2F-await-函数相对于Promise-优势体现在：" class="headerlink" title="async&#x2F;await 函数相对于Promise,优势体现在："></a>async&#x2F;await 函数相对于Promise,优势体现在：</h3><pre class="language-none"><code class="language-none">处理then的调用链，能够更加清晰准确的写出代码并且也能优雅的解决回调地狱的问题。当然async&#x2F;await也存在一些缺点，因为await将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了await会导致性能上的降低，代码没有依赖的话，完全可以使用Promise.all的方式。</code></pre><h3 id="async-x2F-await函数对Generator函数的改造体现以下三点"><a href="#async-x2F-await函数对Generator函数的改造体现以下三点" class="headerlink" title="async&#x2F;await函数对Generator函数的改造体现以下三点:"></a>async&#x2F;await函数对Generator函数的改造体现以下三点:</h3><pre class="language-none"><code class="language-none">内置执行器。Generator函数的执行必须靠执行器，所以才有了co函数库，而async函数自带执行器。也就是说：async函数的执行，与普通函数一模一样，只要一行。更广的实用性。co函数库约定，yield命令后面只能是Thunk函数或者Promise对象，而async函数的await命令后面，可以跟Promise对象和原始类型的值（数值，字符串和布尔值，但这时等同于同步操作）。更好的语义。async和await，比起星号和yield，语义更清楚了，async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</code></pre>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象的三大特征</title>
      <link href="/2022/01/28/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81/"/>
      <url>/2022/01/28/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h2><p><strong>面向对象是一种程序设计思想，将数据和处理数据的程序封装到对象中。</strong></p><ul><li><p>封装:</p><ul><li>将对象运行所需的资源封装在程序对象中，可以隐藏实现的细节，使得代码模块化.</li></ul></li><li><p>继承:</p><ul><li>继承可以解决代码复用。当多个类存在相同的属性和方法时,可以将这些类中抽象出父类,在父类中定义这些相同的属性和方法，所有子类不需要重新定义这些方法和属性，只需要通过继承父类中的方法.</li></ul></li><li><p>多态:</p><ul><li>多态是指一个引用(类型)在不同情况下的多种状态.多态是通过指向父类的引用，来调用在不同子类中实现的方法。多态分为两种:一种是行为多态和对象的多态.</li></ul></li><li><p>优点:</p><ul><li>提高代码的复用性及可维护性。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单页应用和多页应用的区别</title>
      <link href="/2021/04/28/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E5%92%8C%E5%A4%9A%E9%A1%B5%E5%BA%94%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/04/28/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E5%92%8C%E5%A4%9A%E9%A1%B5%E5%BA%94%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="单页应用和多页应有的区别"><a href="#单页应用和多页应有的区别" class="headerlink" title="单页应用和多页应有的区别?"></a>单页应用和多页应有的区别?</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ul><li>SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。</li><li>MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。</li></ul><p><img src="/2021/04/28/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E5%92%8C%E5%A4%9A%E9%A1%B5%E5%BA%94%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/1.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue首屏白屏怎么解决?</title>
      <link href="/2021/03/17/vue%E9%A6%96%E5%B1%8F%E7%99%BD%E5%B1%8F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3/"/>
      <url>/2021/03/17/vue%E9%A6%96%E5%B1%8F%E7%99%BD%E5%B1%8F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="vue首屏白屏怎么解决？"><a href="#vue首屏白屏怎么解决？" class="headerlink" title="vue首屏白屏怎么解决？"></a>vue首屏白屏怎么解决？</h2><ol><li><p>路由懒加载</p></li><li><p>vue-cli开启打包压缩 和后台配合gzip访问</p></li><li><p>进行cdn加速</p></li><li><p>开启vue服务器渲染模式</p></li><li><p>用webpack的externals属性把不需要打包的库文件分离出去，减少打包后的文件大小</p></li><li><p>在生产环境中删除不必要的console.log()</p></li></ol><pre class="language-none"><code class="language-none">plugins: [    new webpack.optimize.UglifyJsPlugin(&#123;    &#x2F;&#x2F;添加-删除     compress:&#123;     warnings:false,     drop_debugger:true,     drop_console:true        &#125;,     sourceMap:true    &#125;),</code></pre><p>开启nginx的gzip,在nginx.conf配置文件中配置</p><pre class="language-none"><code class="language-none">http &#123; &#x2F;&#x2F;在http中配置如下代码，    gzip on;    gzip_disable &quot;msie6&quot;;    gzip_vary on;    gzip_proxied any;    gzip_comp_level 8;        #压缩级别    gzip_buffers 16 8k;    #gzip_http_version 1.1;    gzip_min_length 100;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>json和xml数据的区别是什么？</title>
      <link href="/2020/06/28/json%E5%92%8Cxml%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2020/06/28/json%E5%92%8Cxml%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="json和xml数据的区别是什么"><a href="#json和xml数据的区别是什么" class="headerlink" title="json和xml数据的区别是什么?"></a>json和xml数据的区别是什么?</h2><ul><li>数据体积方面:<ul><li>xml是重量级的</li><li>json是轻量级的，传递的速度更快些。</li></ul></li><li>数据传输方面:<ul><li>xml在传输过程中比较占带宽</li><li>json占带宽少,易于压缩。</li></ul></li><li>数据交互方面:<ul><li>json于javascript的交互更加方便，更容易解析处理，更好的进行数据交互。</li><li>xml和json都用于项目交互下，xml多用于做配置文件，json用于数据交互。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js排序的几种方法</title>
      <link href="/2020/03/28/js%E6%8E%92%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2020/03/28/js%E6%8E%92%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>–</p><h3 id="js排序的几种方法"><a href="#js排序的几种方法" class="headerlink" title="js排序的几种方法"></a>js排序的几种方法</h3><ol><li><p><strong>sort（）排序</strong></p><pre class="language-none"><code class="language-none">var ar1&#x3D;[2,4,6,8,1,3]var ar2&#x3D;[2,16,36,8,56]ar1.sort()ar2.sort()    &#x2F;&#x2F;这个方法值只能排序第一位数  也可以字符串进行排序console.log(ar1)    &#x2F;&#x2F;[1,2,3,4,6,8]console.log(ar2)    &#x2F;&#x2F;[16, 2, 36, 56, 8]ar2.sort(function(a,b)&#123;    return a-b      &#x2F;&#x2F;a-b为升序    &#x2F;&#x2F;return b-a    &#x2F;&#x2F;b-a为降序&#125;)console.log(ar2)&#x2F;&#x2F;[2, 8, 16, 36, 56]</code></pre></li><li><p><strong>reverse()方法</strong></p><pre class="language-none"><code class="language-none">var ar1&#x3D;[2,4,6,8,1,3]ar1.reverse()       &#x2F;&#x2F;此方法为倒序，也就是反过来。并不会进行大小排序console.log(ar1)    &#x2F;&#x2F;[3, 1, 8, 6, 4, 2]</code></pre></li><li><p><strong>冒泡排序</strong></p><pre class="language-none"><code class="language-none">&#x2F;每轮依次比较相邻两个数的大小，后面比前面小则交换var b&#x3D;0&#x2F;&#x2F;设置用来调换位置的值var a&#x3D;[1,9,33,2,5,34,23,98,14]  &#x2F;&#x2F;冒泡排序for(var i&#x3D;0;i&lt;a.length;i++)&#123;    for(var j&#x3D;0;j&lt;a.length;j++)&#123;        if(a[j]&gt;a[j+1])&#123;            b&#x3D;a[j]            a[j]&#x3D;a[j+1]            a[j+1]&#x3D;b        &#125;    &#125;&#125;console.log(a)&#x2F;&#x2F;[1, 2, 5, 9, 14, 23, 33, 34, 98]</code></pre></li><li><p><strong>选择排序</strong></p><pre class="language-none"><code class="language-none">通过比较首先选出最小的数放在第一个位置上，然后在其余的数中选出次小数放在第二个位置上,依此类推,直到所有的数成为有序序列。var arr &#x3D; [9, 8, 7, 6, 5, 4];&#x2F;&#x2F;用选择排序的方法从小到大排列数组元素。&#x2F;&#x2F;比较的轮数for(var i &#x3D; 0; i &lt; arr.length - 1; i++)&#123;&#x2F;&#x2F;每轮比较的次数　　for(var j &#x3D; i + 1; j &lt; arr.length; j++)&#123;　　　　if(arr[i] &gt; arr[j])&#123;　　　　　　var tmp &#x3D; arr[i];　　　　　　arr[i] &#x3D; arr[j];　　　　　　arr[j] &#x3D; tmp;　　　　&#125;　　&#125;&#125;alert(arr);&#x2F;&#x2F;4,5,6,7,8,9</code></pre></li><li><p><strong>快速排序</strong><br>先从数列中取出一个数作为基准数<br>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边<br>再对左右区间重复第二步，直到各区间只有一个数</p><pre class="language-none"><code class="language-none">function quickSort(arr, i, j) &#123;  if(i &lt; j) &#123;    let left &#x3D; i;    let right &#x3D; j;    let mid &#x3D; Math.floor((left+right)&#x2F;2);    let temp &#x3D; arr[left];    arr[left] &#x3D; arr[mid];    arr[mid] &#x3D; temp;    let pivot &#x3D; arr[left];    while(i &lt; j) &#123;      while(arr[j] &gt;&#x3D; pivot &amp;&amp; i &lt; j) &#123;  &#x2F;&#x2F; 从后往前找比基准小的数        j--;      &#125;      if(i &lt; j) &#123;        arr[i++] &#x3D; arr[j];      &#125;      while(arr[i] &lt;&#x3D; pivot &amp;&amp; i &lt; j) &#123;  &#x2F;&#x2F; 从前往后找比基准大的数        i++;      &#125;      if(i &lt; j) &#123;        arr[j--] &#x3D; arr[i];      &#125;    &#125;    arr[i] &#x3D; pivot;    quickSort(arr, left, i-1);    quickSort(arr, i+1, right);    return arr;  &#125;&#125;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
