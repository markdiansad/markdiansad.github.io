<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>什么是高阶组件</title>
      <link href="/2022/06/01/React/%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"/>
      <url>/2022/06/01/React/%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是高阶组件？"><a href="#什么是高阶组件？" class="headerlink" title="什么是高阶组件？"></a>什么是高阶组件？</h2><p><strong>高阶组件就是一个函数，该函数接受一个组件作为参数，并返回一个新的组件</strong><br>基本上，这是从React的组成性质派生的一种模式，我们称他们为”纯”组件，因为他们可以去接受任何动态提供的子组件，但他们不会修改或复制其输入组件的任何行为</p><ul><li>高阶组件（HOC）是React用于复用组件逻辑的一种高级技巧</li><li>高阶组件的参数为一个组件返回一个新组件</li><li>组件将props转化为UI，而高阶组件时将组件转化为另一个组件</li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器存储</title>
      <link href="/2022/05/05/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/"/>
      <url>/2022/05/05/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="我们经常需要对业务中的一些数据进行存储，通常可以分为-短暂性存储-和-持久性储存。"><a href="#我们经常需要对业务中的一些数据进行存储，通常可以分为-短暂性存储-和-持久性储存。" class="headerlink" title="我们经常需要对业务中的一些数据进行存储，通常可以分为 短暂性存储 和 持久性储存。"></a>我们经常需要对业务中的一些数据进行存储，通常可以分为 短暂性存储 和 持久性储存。</h2><ul><li><p>短暂性的时候，我们只需要将数据存在内存中，只在运行时可用</p></li><li><p>持久性存储，可以分为 浏览器端 与 服务器端</p></li><li><p>浏览器</p><ul><li>cookie: 通常用于存储用户身份，登录状态等<ul><li>http 中自动携带， 体积上限为 4K， 可自行设置过期时间</li></ul></li><li>localStorage &#x2F; sessionStorage: 长久储存&#x2F;窗口关闭删除， 体积限制为 4~5M</li><li>indexDB</li></ul></li><li><p>服务器</p><ul><li>分布式缓存 redis</li><li>数据库</li></ul></li></ul><h3 id="cookie和localStorage、session、indexDB-的区别"><a href="#cookie和localStorage、session、indexDB-的区别" class="headerlink" title="cookie和localStorage、session、indexDB 的区别"></a>cookie和localStorage、session、indexDB 的区别</h3><table><thead><tr><th align="left">特性</th><th align="left">cookie</th><th align="left">localStorage</th><th align="left">sessionStorage</th><th align="left">indexDB</th></tr></thead><tbody><tr><td align="left">数据生命周期</td><td align="left">一般由服务器生成，可以设置过期时间</td><td align="left">除非被清理，否则一直存在</td><td align="left">页面关闭就清理</td><td align="left">除非被清理，否则一直存在</td></tr><tr><td align="left">数据存储大小</td><td align="left">4K</td><td align="left">5M</td><td align="left">5M</td><td align="left">无限</td></tr><tr><td align="left">与服务端通信</td><td align="left">每次都会携带在 header 中，对于请求性能影响</td><td align="left">不参与</td><td align="left">不参与</td><td align="left">不参与</td></tr></tbody></table><hr><p><strong>对于 cookie，我们还需要注意安全性</strong></p><table><thead><tr><th align="left">属性</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">value</td><td align="left">如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识</td></tr><tr><td align="left">http-only</td><td align="left">不能通过 JS访问 Cookie，减少 XSS攻击</td></tr><tr><td align="left">secure</td><td align="left">只能在协议为 HTTPS 的请求中携带</td></tr><tr><td align="left">same-site</td><td align="left">规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器缓存机制</title>
      <link href="/2022/05/05/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/05/05/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><ol><li>首先得明确 http 缓存的好处<br>减少了冗余的数据传输，减少网费<br>减少服务器端的压力<br>Web 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间<br>加快客户端加载网页的速度</li><li>常见 http 缓存的类型</li></ol><p>私有缓存（一般为本地浏览器缓存）<br>代理缓存</p><ol start="3"><li>然后谈谈本地缓存<pre class="language-none"><code class="language-none">本地缓存是指浏览器请求资源时命中了浏览器本地的缓存资源，浏览器并不会发送真正的请求给服务器了。</code></pre>第一次浏览器发送请求给服务器时，此时浏览器还没有本地缓存副本，服务器返回资源给浏览器，响应码是200 OK，浏览器收到资源后，把资源和对应的响应头一起缓存下来<br>第二次浏览器准备发送请求给服务器时候，浏览器会先检查上一次服务端返回的响应头信息中的Cache-Control，它的值是一个相对值，单位为秒，表示资源在客户端缓存的最大有效期，过期时间为第一次请求的时间减去Cache-Control的值，过期时间跟当前的请求时间比较，如果本地缓存资源没过期，那么命中缓存，不再请求服务器<br>如果没有命中，浏览器就会把请求发送给服务器，进入缓存协商阶段。</li></ol><pre class="language-none"><code class="language-none">与本地缓存相关的头有：Cache-Control、Expires，Cache-Control有多个可选值代表不同的意义，而Expires就是一个日期格式的绝对值</code></pre><h3 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h3><p><strong>浏览器缓存的位置的话，可以分为四种,优先级从高到低排列分别👇</strong></p><ul><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li></ul><p><strong>Service Worker</strong></p><pre class="language-none"><code class="language-none">这个应用场景比如PWA，它借鉴了Web Worker思路，由于它脱离了浏览器的窗体，因此无法直接访问DOM。它能完成的功能比如：离线缓存、消息推送和网络代理，其中离线缓存就是Service Worker Cache。</code></pre><p><strong>Memory Cache</strong></p><pre class="language-none"><code class="language-none">指的是内存缓存，从效率上讲它是最快的，从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。</code></pre><p><strong>Disk Cache</strong></p><pre class="language-none"><code class="language-none">存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，优势在于存储容量和存储时长。</code></pre><p><strong>Push Cache</strong></p><pre class="language-none"><code class="language-none">推送缓存，这算是浏览器中最后一道防线吧，它是HTTP&#x2F;2的内容</code></pre>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>事件循环和宏任务微任务</title>
      <link href="/2022/04/27/javascript/%E5%AE%8F%E9%98%9F%E5%88%97%E5%92%8C%E5%BE%AE%E9%98%9F%E5%88%97%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
      <url>/2022/04/27/javascript/%E5%AE%8F%E9%98%9F%E5%88%97%E5%92%8C%E5%BE%AE%E9%98%9F%E5%88%97%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="事件循环-宏任务和微任务"><a href="#事件循环-宏任务和微任务" class="headerlink" title="事件循环 宏任务和微任务"></a>事件循环 宏任务和微任务</h2><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><ol><li>js引擎首先必须先执行所有的初始化同步任务代码,遇到异步任务，提交给’异步进程处理’,主线程执行栈会不停监听消息队列是否有异步任务，称位事件循环</li><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ol><p><img src="/2022/04/27/%E5%AE%8F%E9%98%9F%E5%88%97%E5%92%8C%E5%BE%AE%E9%98%9F%E5%88%97%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/1.png"></p><ul><li><strong>宏队列</strong>:<ul><li>用于保存待执行的宏任务（回调）,比如：定时器回调，DOM事件回调,ajax回调</li></ul></li><li><strong>微队列</strong>:<ul><li>用来保存待执行的微任务（回调）,比如：promise的回调，MutationObserver的回调</li></ul></li><li>每次准备取出第一个宏任务执行前，都要将所有的微任务一个一个取出来执行，也就是微任务比宏任务先执行</li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack_优化</title>
      <link href="/2022/04/22/webpack/webpack-%E4%BC%98%E5%8C%96/"/>
      <url>/2022/04/22/webpack/webpack-%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="1、-如何提高webpack的构建速度？"><a href="#1、-如何提高webpack的构建速度？" class="headerlink" title="1、 如何提高webpack的构建速度？"></a>1、 如何提高webpack的构建速度？</h2><ul><li>多入口情况下，使用CommonsChunkPlugin来提取公共代码</li><li>通过externals配置来提取常用库</li><li>利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。</li><li>使用Happypack 实现多线程加速编译</li><li>使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度</li><li>使用Tree-shaking和Scope Hoisting来剔除多余代码</li></ul><h2 id="2、-如何利用webpack来优化前端性能？（提高性能和体验）"><a href="#2、-如何利用webpack来优化前端性能？（提高性能和体验）" class="headerlink" title="2、 如何利用webpack来优化前端性能？（提高性能和体验）!"></a>2、 如何利用webpack来优化前端性能？（提高性能和体验）!</h2><p>用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。</p><ul><li>压缩代码<ul><li>删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css</li></ul></li><li>利用CDN加速<ul><li>在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径</li></ul></li><li>删除死代码<ul><li>将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数–optimize-minimize来实现</li></ul></li><li>提取公共代码<ul><li>异步组件    — 异步图片   — 配置webpack对小图片打包成base64字符  减少io请求</li></ul></li></ul><h2 id="3、-怎么配置单页应用？怎么配置多页应用？"><a href="#3、-怎么配置单页应用？怎么配置多页应用？" class="headerlink" title="3、 怎么配置单页应用？怎么配置多页应用？"></a>3、 怎么配置单页应用？怎么配置多页应用？</h2><ul><li>单页应用<ul><li>可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可</li></ul></li><li>多页应用<ul><li>可以使用webpack的 AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。</li></ul></li></ul><h2 id="4、-如何提升webpack的运行速度-开发环境-有哪些策略？"><a href="#4、-如何提升webpack的运行速度-开发环境-有哪些策略？" class="headerlink" title="4、 如何提升webpack的运行速度(开发环境) ,有哪些策略？"></a>4、 如何提升webpack的运行速度(开发环境) ,有哪些策略？</h2><ul><li><p>多入口情况下，使用CommonsChunkPlugin来提取公共代码</p></li><li><p>通过externals配置来提取常用库</p></li><li><p>利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。</p></li><li><p>使用Happypack 实现多线程加速编译</p></li><li><p>使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度</p></li><li><p>使用Tree-shaking和Scope Hoisting来剔除多余代码</p></li><li><p>JS代码压缩</p><ul><li>terser是一个JavaScript的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让bundle更小。在production模式下，webpack 默认就是使用 TerserPlugin 来处理我们的代码的。</li><li>TerserPlugin常用的属性如下： - extractComments：默认值为true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释 - parallel：使用多进程并发运行提高构建的速度，默认值是true，并发运行的默认数量： os.cpus().length - 1 - terserOptions：设置我们的terser相关的配置： compress：设置压缩相关的选项，mangle：设置丑化相关的选项，可以直接设置为true mangle：设置丑化相关的选项，可以直接设置为true toplevel：底层变量是否进行转换keep_classnames：保留类的名称 keep_fnames：保留函数的名称</li></ul></li><li><p>代码压缩</p><ul><li>cssCSS压缩通常用于去除无用的空格等，不过因为很难去修改选择器、属性的名称、值等，所以我们可以使用另外一个插件：css-minimizer-webpack-plugin</li></ul></li><li><p>Html文件代码压缩</p></li><li><p>文件大小压缩</p><ul><li>对文件的大小进行压缩，可以有效减少http传输过程中宽带的损耗，文件压缩需要用到 compression-webpack-plugin插件</li></ul></li><li><p>图片压缩</p><ul><li>如果我们对bundle包进行分析，会发现图片等多媒体文件的大小是远远要比 js、css 文件要大的，所以图片压缩在打包方面也是很重要的</li></ul></li><li><p>Tree Shaking</p><ul><li>Tree Shaking 是一个术语，在计算机中表示消除死代码，依赖于ES Module的静态语法分析。在webpack实现Trss shaking有两种不同的方案： usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的 sideEffects：跳过整个模块&#x2F;文件，直接查看该文件是否有副作用</li><li>usedExports的配置方法很简单，只需要将usedExports设为true即可，如下。而sideEffects则用于告知webpack compiler在编译时哪些模块有副作用，配置方法是在package.json中设置sideEffects属性。如果sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports，如果有些文件需要保留，可以设置为数组的形式。</li></ul></li><li><p>代码分离</p></li><li><ul><li>默认情况下，所有的JavaScript代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载， 就会影响首页的加载速度。如果可以分出出更小的bundle，以及控制资源加载优先级，从而优化加载性能。</li></ul></li><li><ul><li>代码分离可以通过splitChunksPlugin来实现，该插件webpack已经默认安装和集成，只需要配置即可。</li></ul></li><li><ul><li>splitChunks有如下几个属性： Chunks：对同步代码还是异步代码进行处理 minSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分 maxSize： 将大于maxSize的包，拆分为不小于minSize的包 minChunks：被引入的次数，默认是1</li></ul></li><li><p>内联 chunk</p></li><li><ul><li>可以通过InlineChunkHtmlPlugin插件将一些chunk的模块内联到html，如runtime的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大但是必须加载的，比如：总结一下，Webpack对前端性能的优化，主要是通过文件体积大小入手，主要的措施有分包、减少Http请求次数等。</li></ul></li></ul><h2 id="5、-npm打包时需要注意哪些？如何利用webpack来更好的构建？"><a href="#5、-npm打包时需要注意哪些？如何利用webpack来更好的构建？" class="headerlink" title="5、 npm打包时需要注意哪些？如何利用webpack来更好的构建？"></a>5、 npm打包时需要注意哪些？如何利用webpack来更好的构建？</h2><pre class="language-none"><code class="language-none">Npm是目前最大的 JavaScript 模块仓库，里面有来自全世界开发者上传的可复用模块。你可能只是JS模块的使用者，但是有些情况你也会去选择上传自己开发的模块。关于NPM模块上传的方法可以去官网上进行学习，这里只讲解如何利用webpack来构建。NPM模块需要注意以下问题：要支持CommonJS模块化规范，所以要求打包后的最后结果也遵守该规则。Npm模块使用者的环境是不确定的，很有可能并不支持ES6，所以打包的最后结果应该是采用ES5编写的。并且如果ES5是经过转换的，请最好连同SourceMap一同上传。Npm包大小应该是尽量小（有些仓库会限制包大小）发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。UI组件类的模块应该将依赖的其它资源文件，例如.css文件也需要包含在发布的模块里。</code></pre><h2 id="6、-什么是长缓存？在webpack中如何做到长缓存优化？"><a href="#6、-什么是长缓存？在webpack中如何做到长缓存优化？" class="headerlink" title="6、 什么是长缓存？在webpack中如何做到长缓存优化？"></a>6、 什么是长缓存？在webpack中如何做到长缓存优化？</h2><ul><li>浏览器在用户访问页面的时候，为了加快加载速度，会对用户访问的静态资源进行存储，但是每一次代码升级或者更新，都需要浏览器去下载新的代码，最方便和最简单的更新方式就是引入新的文件名称。</li><li>在webpack中，可以在output给出输出的文件制定chunkhash，并且分离经常更新的代码和框架代码，通过NameModulesPlugin或者HashedModulesPlugin使再次打包文件名不变。</li></ul><h2 id="7、-在项目中tree-shaking摇树不是很干净，有什么解决方案？"><a href="#7、-在项目中tree-shaking摇树不是很干净，有什么解决方案？" class="headerlink" title="7、 在项目中tree-shaking摇树不是很干净，有什么解决方案？"></a>7、 在项目中tree-shaking摇树不是很干净，有什么解决方案？</h2><ul><li>在webpack.config.js中通过</li><li>来进行tree-shaking 但是单单指定这一个配置  不是很干净</li><li>有些模块导入，只要被引入，</li><li>就会对应用程序产生重要的影响。一个很好的例子就是全局样式表，或者设置全局配置的JavaScript 文件。</li></ul><h2 id="8、-怎么提高webpack的打包效率？"><a href="#8、-怎么提高webpack的打包效率？" class="headerlink" title="8、 怎么提高webpack的打包效率？"></a>8、 怎么提高webpack的打包效率？</h2><ul><li>开发环境优化<ul><li><ol><li>开启热模块替换（HMR）</li></ol></li><li><ol start="2"><li>使用 source-map 进行源代码映射</li></ol></li><li><ol start="3"><li>将只需要被loader执行一次的规则放到 oneOf 里面去</li></ol></li></ul></li><li>生产环境优化<ul><li><ol><li>对资源进行缓存</li></ol></li><li><ol start="2"><li>使用tree shaking（树摇）</li></ol></li><li><ol start="3"><li>使用code split 进行代码分割</li></ol></li><li><ol start="4"><li>文件懒加载和预加载</li></ol></li><li><ol start="5"><li>多进程打包</li></ol></li><li><ol start="6"><li>使用PWA（离线加载）</li></ol></li><li><ol start="7"><li>使用externals 忽略某些包，然后通过cdn引入</li></ol></li><li><ol start="8"><li>使用dll 技术对某些库（第三方库）进行单独打包</li></ol></li></ul></li></ul><h2 id="9、-按需加载的原理"><a href="#9、-按需加载的原理" class="headerlink" title="9、 按需加载的原理"></a>9、 按需加载的原理</h2><ul><li>使用符合ECMAScript 提案的import()语法</li><li>使用 webpack 特定的require.ensure</li></ul><h2 id="10、-预获取-x2F-预加载模块"><a href="#10、-预获取-x2F-预加载模块" class="headerlink" title="10、 预获取&#x2F;预加载模块"></a>10、 预获取&#x2F;预加载模块</h2><pre class="language-none"><code class="language-none">Webpack v4.6.0+ 增加了对预获取和预加载的支持。在声明 import 时，使用下面这些内置指令，可以让 webpack 输出 &quot;resource hint(资源提示)&quot;，来告知浏览器●  prefetch(预获取)：将来某些导航下可能需要的资源● preload(预加载)：当前导航下可能需要资源添加第二句魔法注释： webpackPrefetch: true告诉 webpack 执行预获取。这会生成 &lt;link rel&#x3D;&quot;prefetch&quot; href&#x3D;&quot;math.js&quot;&gt;       并追加到页面头部，指示着浏览器在闲置时间预取 math.js 文件。</code></pre><h2 id="12-什么是Tree-sharking"><a href="#12-什么是Tree-sharking" class="headerlink" title="12.  什么是Tree-sharking?"></a>12.  什么是Tree-sharking?</h2><ul><li>Tree是树，sharking是摇晃的意思。那么树摇晃的时候，肯定会’摇’下来一些无用的叶子。从编程的角度思考，如果假设我们的代码是一棵树（Tree），那么摇下来的无用的的叶子是什么呢？当然是无用的代码啦，他有个专业的术语，叫做dead-code（死码）</li><li>指打包中去除那些引入了但在代码中没用到的死代码。在wepack中js treeshaking通过UglifyJsPlugin来进行，css中通过purify-CSS来进行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack5_Loader</title>
      <link href="/2022/04/21/webpack/webpack-Loader/"/>
      <url>/2022/04/21/webpack/webpack-Loader/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack-Loader整理"><a href="#webpack-Loader整理" class="headerlink" title="webpack Loader整理"></a>webpack Loader整理</h1><h2 id="1-Loader机制的作用是什么？"><a href="#1-Loader机制的作用是什么？" class="headerlink" title="1. Loader机制的作用是什么？"></a>1. Loader机制的作用是什么？</h2><ul><li>webpack 本身只能处理 JavaScript 和 JSON 文件，而 loader 为 webpack 添加了处理其他类型文件的能力。</li><li>webpack默认只能打包js文件，配置里的module.rules数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换打包成js。<pre class="language-none"><code class="language-none">注意：use属性的值需要是一个由 Loader 名称组成的数组，Loader 的执行顺序是由后到前的；每一个 Loader 都可以通过 URL querystring 的方式传入参数，例如css-loader?minimize中的minimize告诉css-loader要开启 CSS 压缩。</code></pre></li></ul><h2 id="2-有哪些常见的Loader？他们是解决什么问题的？"><a href="#2-有哪些常见的Loader？他们是解决什么问题的？" class="headerlink" title="2. 有哪些常见的Loader？他们是解决什么问题的？"></a>2. 有哪些常见的Loader？他们是解决什么问题的？</h2><pre class="language-none"><code class="language-none">file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去source-map-loader：加载额外的 Source Map 文件，以方便断点调试image-loader：加载并且压缩图片文件babel-loader：把 ES6 转换成 ES5css-loader：加载 CSS，支持模块化、压缩、文件导入等特性style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。eslint-loader：通过 ESLint 检查 JavaScript 代码</code></pre><h2 id="3-Webpack-的-Loader-是什么？"><a href="#3-Webpack-的-Loader-是什么？" class="headerlink" title="3. Webpack 的 Loader 是什么？"></a>3. Webpack 的 Loader 是什么？</h2><p>Webpack 只能理解 JavaScript 和 JSON 文件，这是 Webpack 开箱可用的自带能力。loader 可以让 Webpack 能够去处理其他类型的文件，chunk 文件以供应用程序使用，以及被添加到依赖图中，也可将内联图像转换为 data URL。简单来说，loader 可以将一段代码转换成另一端代码，通常用来将一段特殊代码转换成一段浏览器可识别的代码。</p><ul><li>loader 有两个属性：<ul><li>test，正则表达式，用于识别出哪些文件会被转换，</li><li>use 定义在进行转换时应该使用哪个<ul><li>loader，可以是字符串、数组和对象。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack5_Plugin</title>
      <link href="/2022/04/21/webpack/webpack-Plugin/"/>
      <url>/2022/04/21/webpack/webpack-Plugin/</url>
      
        <content type="html"><![CDATA[<p>–</p><h1 id="webpack-Plugin整理"><a href="#webpack-Plugin整理" class="headerlink" title="webpack Plugin整理"></a>webpack Plugin整理</h1><h2 id="1-Plugin（插件）的作用是什么？"><a href="#1-Plugin（插件）的作用是什么？" class="headerlink" title="1. Plugin（插件）的作用是什么？"></a>1. Plugin（插件）的作用是什么？</h2><p>通过安装和配置第三方的插件，可以拓展 webpack 的能力，从而让 webpack 用起来更方便。最常用的webpack 插件有如下两个：</p><ul><li><p>webpack-dev-server</p><ul><li>类似于 node.js 阶段用到的 nodemon 工具每当修改了源代码，webpack 会自动进行项目的打包和构建</li></ul></li><li><p>html-webpack-plugin</p><ul><li>webpack 中的 HTML 插件（类似于一个模板引擎插件）可以通过此插件自定制 index.html 页面的内容</li></ul></li></ul><p><strong>webpack-dev-server 可以让 webpack 监听项目源代码的变化，从而进行自动打包构建。</strong></p><pre class="language-none"><code class="language-none">修改package.json -&gt; scripts中的dev命令：&quot;scripts&quot;:&#123;      &quot;dev&quot;：&quot;webpack serve&quot;，&#x2F;&#x2F; script 节点下的脚本,可以通过 npm run 执行&#125;</code></pre><h2 id="2-有哪些常见的Plugin？他们是解决什么问题的？"><a href="#2-有哪些常见的Plugin？他们是解决什么问题的？" class="headerlink" title="2. 有哪些常见的Plugin？他们是解决什么问题的？"></a>2. 有哪些常见的Plugin？他们是解决什么问题的？</h2><pre class="language-none"><code class="language-none">define-plugin：定义环境变量commons-chunk-plugin：提取公共代码uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码purgecss-webpack-plugin：擦除无用csshappypack：多线程处理打包webpack-bundle-analyzer：打包分析speed-measure-webpack-plugin：构建速度分析html-webpack-plugin：为html文件中引入的外部资源如script、link动态添加每次compile后的hash，防止引用缓存的外部文件问题</code></pre><h2 id="3-Webpack-的-Plugin-是什么？"><a href="#3-Webpack-的-Plugin-是什么？" class="headerlink" title="3. Webpack 的 Plugin 是什么？"></a>3. Webpack 的 Plugin 是什么？</h2><p>plugin是插件的意思，通常是用于对某个现有的架构进行扩展。<br>        &#x3D;&#x3D;&gt; webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等。</p><h2 id="4-Loader和Plugin的不同？"><a href="#4-Loader和Plugin的不同？" class="headerlink" title="4. Loader和Plugin的不同？"></a>4. Loader和Plugin的不同？</h2><h3 id="不同的作用"><a href="#不同的作用" class="headerlink" title="不同的作用"></a>不同的作用</h3><ul><li>Loader直译为”加载器”。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力</li><li>Plugin直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li></ul><h3 id="不同的用法"><a href="#不同的用法" class="headerlink" title="不同的用法"></a>不同的用法</h3><ul><li>Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）</li><li>Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。</li></ul><h3 id="4-描述一下编写loader或plugin的思路？"><a href="#4-描述一下编写loader或plugin的思路？" class="headerlink" title="4.描述一下编写loader或plugin的思路？"></a>4.描述一下编写loader或plugin的思路？</h3><pre class="language-none"><code class="language-none">Loader像一个&quot;翻译官&quot;把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。编写Loader时要遵循单一原则，每个Loader只做一种&quot;转义&quot;工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack整理</title>
      <link href="/2022/04/20/webpack/webpack%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/04/20/webpack/webpack%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>–</p><h1 id="webpack5概念"><a href="#webpack5概念" class="headerlink" title="webpack5概念"></a>webpack5概念</h1><h2 id="1-谈谈你对Webpack的理解？"><a href="#1-谈谈你对Webpack的理解？" class="headerlink" title="1.谈谈你对Webpack的理解？"></a>1.谈谈你对Webpack的理解？</h2><p>是一个模块化打包工具，将不同的资源和文件，进行打包，合并在一个文件里。</p><pre class="language-none"><code class="language-none">1、依赖管理：方便引用第三方模块，让模块更容易复用、避免全局注入导致的冲突、、避免重复加载或者加载不必要的模块2、合并代码：把各个分散的模块集中打包成大文件，减少HTTP的链接的请求次数，配合uglify.js可以减少、优化代码的体积3、各种插件：babel把ES6+转[webpack5整理]()化为ES5-，eslint可以检查编译时的各种错误</code></pre><h2 id="2-webpack的工作原理"><a href="#2-webpack的工作原理" class="headerlink" title="2.webpack的工作原理?"></a>2.webpack的工作原理?</h2><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><pre class="language-none"><code class="language-none">1. Entry:入口指示webpack以哪个文件为入口起点开始打包，分析构建内部依赖图2. output:输出指示webpack的打包后的资源bundles输出到哪里去，以及如何命名3. Loader:让webpack能够去处理哪些非JavaScrip文件（webpack自身只理解javaScript)4. plugin:插件可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等5. mode:模式指示webpack使用相应模式的配置</code></pre><h4 id="流程概括"><a href="#流程概括" class="headerlink" title="流程概括"></a>流程概括</h4><pre class="language-none"><code class="language-none">webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：1. 初始化参数：从配置文件和Shell语句中读取与合并参数，得出最终的参数；2. 开始编译： 用上一步得到的参数初始化Complier对象，加载所有配置的插件，执行对象的run方法开始执行编译；3. 确定入口： 根据配置中的entry找出所有入口文件；4. 编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理；5. 完成模块编译： 在经过第4步使用Loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及他们之间的依赖关系；6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；7. 输出完成： 在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。在以上过程中，webpack会在特定的时间点广播出特定的时间，插件在监听到感兴趣的时间后会执行特定的逻辑，并且插件可以调用Webpack提供的API改变Webpack的运行结果。</code></pre><h4 id="流程细节"><a href="#流程细节" class="headerlink" title="流程细节"></a>流程细节</h4><ul><li>Webpack的构建流程可以分为以下三个阶段：<ul><li><ol><li>初始化：启动构建，读取与合并配置参数，加载Plugin，实例化Complier.</li></ol></li><li><ol start="2"><li>编译：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件内容，再找到该Module依赖的Module，递归地进行编译处理。</li></ol></li><li><ol start="3"><li>输出： 对编译后的Module组合成Chunk，把Chunk转换成文件，输出到文件系统。</li></ol></li></ul></li></ul><h2 id="3-webpack4和webpack5的区别？"><a href="#3-webpack4和webpack5的区别？" class="headerlink" title="3.webpack4和webpack5的区别？"></a>3.webpack4和webpack5的区别？</h2><pre class="language-none"><code class="language-none">更快的构建速度更高的版本要求更灵活的模块组合更智能的缓存优化更小的体积webpack4 上需要下载安装 terser-webpack-plugin 插件webpack5 内部本身就自带 js 压缩功能，他内置了 terser-webpack-plugin 插件，我们不用再下载安装。而且在 mode&#x3D;“production” 的时候会自动开启 js 压缩功能。webpack4 缓存配置    &#x3D;&#x3D;&gt; npm install hard-source-webpack-plugin -D    webpack5 缓存配置    &#x3D;&#x3D;&gt; webpack5 内部内置了 cache 缓存机制。直接配置即可。    &#x3D;&#x3D;&gt; cache 会在开发模式下被设置成 type： memory 而且会在生产模式把cache 给禁用掉。webpack4 启动服务    &#x3D;&#x3D;&gt; 通过 webpack-dev-server 启动服务 webpack5 启动服务    &#x3D;&#x3D;&gt; 内置使用 webpack serve 启动，但是他的日志不是很好，所以一般都加都喜欢用 webpack-dev-server 优化。打包的区别● webpack4打包:即使后续没有使用到num1的函数，依然会将代码打包进去● webpack5打包:后续没有使用到num1的函数，不会将代码打包进去输出代码的区别● webpack4只能输出es5的代码● webpack5新增属性output.ecmaVersion，可以生成ES5和ES6的代码</code></pre><h2 id="4-前端代码为何要进行构建和打包？"><a href="#4-前端代码为何要进行构建和打包？" class="headerlink" title="4. 前端代码为何要进行构建和打包？"></a>4. 前端代码为何要进行构建和打包？</h2><ul><li><p>代码方面体积更小，加载更快（tree-shaking，压缩合并）</p><ul><li>编译高级语言和语法（ts，es6，模块化）</li><li>兼容性和错误提示（polyfill，postcss，eslint）</li></ul></li><li><p>研发流程统一、高效的开发环境</p><ul><li>统一的构建流程和产出标准</li><li>集成公司构建规范（提测，上线）</li></ul></li></ul><h2 id="5-webpack的优缺点？"><a href="#5-webpack的优缺点？" class="headerlink" title="5. webpack的优缺点？"></a>5. webpack的优缺点？</h2><ol><li>优点<ul><li>webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD&#x2F;CMD 的支持也很全面，方便旧项目进行代码迁移。</li><li>能被模块化的不仅仅是 JS 了。</li><li>开发便捷，能替代部分 grunt&#x2F;gulp 的工作，比如打包、压缩混淆、图片转base64等。</li><li>扩展性强，插件机制完善</li></ul></li><li>缺点<ul><li>配置复杂</li><li>不分包bundle.js体积庞大</li><li>只能用于采用模块化开发的项目</li><li>打包慢</li><li>ES模块除Module外全用babel转换，但是一部分ES2015 语法的 firefox 与 chrome 浏览器中能直接跑的代码，无法用 webpack 编译</li></ul></li></ol><h2 id="6-什么是bundle，什么是chunk，什么是module"><a href="#6-什么是bundle，什么是chunk，什么是module" class="headerlink" title="6. 什么是bundle，什么是chunk，什么是module"></a>6. 什么是bundle，什么是chunk，什么是module</h2><pre class="language-none"><code class="language-none">bundle： 是由webpack打包出来的文件chunk： 是指webpack在进行模块依赖分析的时候，代码分割出来的代码块module： 是开发中的单个模块</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝和浅拷贝</title>
      <link href="/2022/03/21/javascript/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2022/03/21/javascript/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p><strong>浅拷贝和深拷贝都只针对于引用数据类型</strong></p><ul><li>浅拷贝<ul><li>只复制指向对象的指针,而不复制对象本身，新旧对象还是共享同一块内存;</li></ul></li><li>深拷贝<ul><li>另外创造一个一模一样的对象,新对象跟原对象不共享内存,修改新对象不会影响到原对象</li></ul></li></ul><h3 id="浅拷贝实现方法"><a href="#浅拷贝实现方法" class="headerlink" title="浅拷贝实现方法"></a>浅拷贝实现方法</h3><pre class="language-none"><code class="language-none">1.Object.assign方法var obj &#x3D; &#123;    a:1,    b:2&#125;var obj1 &#x3D; Object.assign(&#123;&#125;,obj)obj1.a &#x3D; 3:console.log(obj.a) &#x2F;&#x2F; 32.解构赋值var obj1 &#x3D; &#123;a: 1, b: 2&#125;var obj2 &#x3D; &#123;...obj1&#125;obj2.a &#x3D; 4console.log(obj1, obj2)</code></pre><h3 id="深拷贝实现方法"><a href="#深拷贝实现方法" class="headerlink" title="深拷贝实现方法"></a>深拷贝实现方法</h3><pre class="language-none"><code class="language-none">1.json.stringify()方法var obj1 &#x3D; [&#123;    name: &#39;臧三&#39;,    childs: [&#39;小明&#39;, &#39;小芳&#39;]&#125;]var obj2 &#x3D; JSON.parse(JSON.stringify(obj1))obj2[0].childs &#x3D; []console.log(obj1, obj2)2.递归方法var obj1 &#x3D; [&#123;    name: &#39;臧三&#39;,    childs: [&#39;小明&#39;, &#39;小芳&#39;],    fn: function() &#123;&#125;,    age: undefined&#125;]var obj2 &#x3D; extend(obj1)obj2[0].childs &#x3D; []console.log(obj1, obj2)function extend(data) &#123;    if (typeof data &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; data) &#123;        let val &#x3D; typeof data.length &#x3D;&#x3D;&#x3D; &#39;number&#39; ? [] : &#123;&#125;        for(let i in data) &#123;            val[i] &#x3D; extend(data[i])        &#125;        return val    &#125; else &#123;        return data    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>闭包的理解</title>
      <link href="/2022/03/14/javascript/%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2022/03/14/javascript/%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>–</p><h2 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h2><p>一个函数和对其他周围状态的引用捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包</strong>。<br>闭包可以在一个内层函数中访问到外层函数的作用域。</p><h3 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h3><ul><li>可以让外部访问函数内部的变量。</li><li>可以避免使用全局变量。防止全局变量污染。</li><li>可以让局部变量常驻在内存中</li><li>会造成内存泄露(有一个内存空间长期被占用，而不被释放)</li></ul><h3 id="闭包示例"><a href="#闭包示例" class="headerlink" title="闭包示例"></a>闭包示例</h3><pre class="language-none"><code class="language-none"> function fn1()&#123;            var max &#x3D; 10;            return function (x) &#123;                if(x &gt; max)&#123;                    console.log(x);                &#125;            &#125;        &#125;var fn2 &#x3D; fn1();fn2(20);</code></pre>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>防抖与节流</title>
      <link href="/2022/02/27/javascript/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
      <url>/2022/02/27/javascript/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p><strong>在事件被触发的n秒后再执行回调,如果这n秒又被触发，则重新计时.高频操作下，只执行最后一次.</strong></p><pre class="language-none"><code class="language-none">&lt;script&gt;    &#x2F;&#x2F; 防抖  用户触发事件过于频繁    let inp &#x3D; document.getElementsByTagName(&#39;input&#39;)    inp[0].oninput &#x3D; deco(function () &#123;        console.log(this.value)    &#125;, 500)    function deco(fn, time) &#123;        let t &#x3D; null;        return function () &#123;            if (t) &#123;                clearTimeout(t)            &#125;            t &#x3D; setTimeout(() &#x3D;&gt; &#123;                fn.call(this)            &#125;, time)        &#125;    &#125;&lt;&#x2F;script&gt;</code></pre><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p><strong>一定时间内 控制触发的次数</strong></p><pre class="language-none"><code class="language-none">&lt;script&gt;  window.onscroll &#x3D; fn(function () &#123;        console.log(1111111)    &#125;, 500)    function fn(fn1, time) &#123;        let flag &#x3D; true;        return function () &#123;            if (flag) &#123;                setTimeout(() &#x3D;&gt; &#123;                    fn1.call(this)                    flag &#x3D; true                &#125;, time)            &#125;            flag &#x3D; false;        &#125;    &#125;&lt;&#x2F;script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实现异步的方法</title>
      <link href="/2022/02/21/javascript/%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2022/02/21/javascript/%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="实现异步的方法"><a href="#实现异步的方法" class="headerlink" title="实现异步的方法"></a>实现异步的方法</h2><ul><li>回调函数(Callback)</li><li>事件监听</li><li>发布订阅</li><li>promise</li><li>生成器(Generators&#x2F;yield)</li><li>async&#x2F;await</li></ul><p><strong>js异步编程进化史: callback –&gt; promise –&gt; generator –&gt;async + await</strong></p><p>async&#x2F;await函数的实现，就是将Generator函数和自动执行器，包装在一个函数里<br>async&#x2F;await 可以说是异步终极解决方案了。</p><h3 id="async-x2F-await-函数相对于Promise-优势体现在："><a href="#async-x2F-await-函数相对于Promise-优势体现在：" class="headerlink" title="async&#x2F;await 函数相对于Promise,优势体现在："></a>async&#x2F;await 函数相对于Promise,优势体现在：</h3><pre class="language-none"><code class="language-none">处理then的调用链，能够更加清晰准确的写出代码并且也能优雅的解决回调地狱的问题。当然async&#x2F;await也存在一些缺点，因为await将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了await会导致性能上的降低，代码没有依赖的话，完全可以使用Promise.all的方式。</code></pre><h3 id="async-x2F-await函数对Generator函数的改造体现以下三点"><a href="#async-x2F-await函数对Generator函数的改造体现以下三点" class="headerlink" title="async&#x2F;await函数对Generator函数的改造体现以下三点:"></a>async&#x2F;await函数对Generator函数的改造体现以下三点:</h3><pre class="language-none"><code class="language-none">内置执行器。Generator函数的执行必须靠执行器，所以才有了co函数库，而async函数自带执行器。也就是说：async函数的执行，与普通函数一模一样，只要一行。更广的实用性。co函数库约定，yield命令后面只能是Thunk函数或者Promise对象，而async函数的await命令后面，可以跟Promise对象和原始类型的值（数值，字符串和布尔值，但这时等同于同步操作）。更好的语义。async和await，比起星号和yield，语义更清楚了，async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</code></pre>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象的三大特征</title>
      <link href="/2022/01/28/javascript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81/"/>
      <url>/2022/01/28/javascript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h2><p><strong>面向对象是一种程序设计思想，将数据和处理数据的程序封装到对象中。</strong></p><ul><li><p>封装:</p><ul><li>将对象运行所需的资源封装在程序对象中，可以隐藏实现的细节，使得代码模块化.</li></ul></li><li><p>继承:</p><ul><li>继承可以解决代码复用。当多个类存在相同的属性和方法时,可以将这些类中抽象出父类,在父类中定义这些相同的属性和方法，所有子类不需要重新定义这些方法和属性，只需要通过继承父类中的方法.</li></ul></li><li><p>多态:</p><ul><li>多态是指一个引用(类型)在不同情况下的多种状态.多态是通过指向父类的引用，来调用在不同子类中实现的方法。多态分为两种:一种是行为多态和对象的多态.</li></ul></li><li><p>优点:</p><ul><li>提高代码的复用性及可维护性。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js类型检测</title>
      <link href="/2021/12/05/javascript/js%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B/"/>
      <url>/2021/12/05/javascript/js%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="JS内置类型"><a href="#JS内置类型" class="headerlink" title="JS内置类型"></a>JS内置类型</h3><p><img src="https://s.poetries.work/images/20210414100319.png"></p><p>JavaScript一共有8种数据类型，其中有7种基本数据类型：Undefined、Null、Boolean、Number、String、<br>Symbol（es6新增，表示独一无二的值）和BigInt（es10新增）；</p><p><strong>原始数据类型</strong><br>基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</p><hr><p><strong>引用数据类型</strong><br>引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念；占据空间大、大小不固定。<br>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p><hr><h3 id="数据类型检测"><a href="#数据类型检测" class="headerlink" title="数据类型检测"></a>数据类型检测</h3><ol><li>typeof<ul><li>typeof 对于原始类型来说，除了 null 都可以显示正确的类型</li></ul></li><li>instanceof<ul><li>可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype</li></ul></li><li>constructor<ul><li>如果我创建一个对象，更改它的原型，constructor就会变得不可靠了</li></ul></li><li>Object.prototype.toString.call()<ul><li>toString() 是 Object 的原型方法，调用该方法，可以统一返回格式为 “[object Xxx]” 的字符串</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue中$nextTick作用于原理</title>
      <link href="/2021/11/12/Vue/vue%E4%B8%AD-nextTick%E4%BD%9C%E7%94%A8%E4%BA%8E%E5%8E%9F%E7%90%86/"/>
      <url>/2021/11/12/Vue/vue%E4%B8%AD-nextTick%E4%BD%9C%E7%94%A8%E4%BA%8E%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="vue中-nextTick的作用与原理"><a href="#vue中-nextTick的作用与原理" class="headerlink" title="vue中$nextTick的作用与原理"></a>vue中$nextTick的作用与原理</h2><pre class="language-none"><code class="language-none">作用：是为了可以获取更新后的DOM。</code></pre><p>由于Vue DOM更新是异步执行的,即修改数据时，视图不会立即更新，而是会监听数据变化,并缓存<br>在同一事件循环中,等同一数据循环中,等统一数据循环中的所有数据变化完成之后,再统一进行视图更新.<br>为了确保得到更新后的DOM，所以设置了Vue.nextTick(),就是在下次DOM更新循环结束之后执行延迟回调.<br>在修改数据之后立即使用这个方法,获取更新后的DOM。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在下次DOM更新循环结束之后执行延迟回调.nextTick主要使用了宏任务和微任务.根据执行环境分别尝试采用</p><ul><li>Promise</li><li>MutationObserver</li><li>setlmmediate<br>如果以上都不行则采用setTimeout</li></ul><p>定义了一个异步方法,多次调用nextTick会将方法存入队列当中，通过这个异步方法清空当前队列.</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器如何渲染网页?</title>
      <link href="/2021/08/06/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E7%BD%91%E9%A1%B5/"/>
      <url>/2021/08/06/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E7%BD%91%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h2><p><strong>浏览器渲染一共有五步</strong></p><ol><li>处理 HTML 并构建 DOM 树。</li><li>处理 CSS构建 CSSOM 树。</li><li>将 DOM 与 CSSOM 合并成一个渲染树。</li><li>根据渲染树来布局，计算每个节点的位置。</li><li>调用 GPU 绘制，合成图层，显示在屏幕上</li></ol><p><strong>第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染</strong></p><p><img src="https://s.poetries.work/gitee/2019/10/19.png"><br><img src="https://s.poetries.work/gitee/2019/10/20.png"></p><p><strong>重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大</strong></p><ul><li>重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘</li><li>回流是布局或者几何属性需要改变就称为回流。<pre class="language-none"><code class="language-none">回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流</code></pre></li></ul><h3 id="以下几个动作可能会导致性能问题"><a href="#以下几个动作可能会导致性能问题" class="headerlink" title="以下几个动作可能会导致性能问题"></a>以下几个动作可能会导致性能问题</h3><ul><li>改变 window 大小</li><li>改变字体</li><li>添加或删除样式</li><li>文字改变</li><li>定位或者浮动</li><li>盒模型</li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单页应用和多页应用的区别</title>
      <link href="/2021/04/28/Vue/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E5%92%8C%E5%A4%9A%E9%A1%B5%E5%BA%94%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/04/28/Vue/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E5%92%8C%E5%A4%9A%E9%A1%B5%E5%BA%94%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="单页应用和多页应有的区别"><a href="#单页应用和多页应有的区别" class="headerlink" title="单页应用和多页应有的区别?"></a>单页应用和多页应有的区别?</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ul><li>SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。</li><li>MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。</li></ul><p><img src="/2021/04/28/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E5%92%8C%E5%A4%9A%E9%A1%B5%E5%BA%94%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/1.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HashRouter和HistoryRouter的区别和原理</title>
      <link href="/2021/04/03/Vue/HashRouter%E5%92%8CHistoryRouter%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%8E%9F%E7%90%86/"/>
      <url>/2021/04/03/Vue/HashRouter%E5%92%8CHistoryRouter%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="HashRouter和HistoryRouter的区别和原理"><a href="#HashRouter和HistoryRouter的区别和原理" class="headerlink" title="HashRouter和HistoryRouter的区别和原理"></a>HashRouter和HistoryRouter的区别和原理</h2><p><strong>vue-router</strong>是Vue官方的路由管理器。它和Vue.js的核心深度集成，让构建单页面应用变得简单。<br>vue-router默认hash模式，还有一种是history模式。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>hash路由:<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &gt;<br>hash模式的工作原理是hashchange事件，可以在window监听hash的变化，我们在url后面随便添加一个#xx触发这个事件。<br>vue-router默认是hash模式–使用url的hash来模拟一个完整的url，于是当url改变的时候，页面不会重新加载，也就是单页应用<br>当#后面的hash发生变化，不会导致浏览器向服务器发出请求，浏览器不发出请求就不会刷新页面，并且会触发hashChange这个事件，通过监听<br>hash值的变化来实现更新页面部分内容操作<br>对于hash模式会创建hashHistory对象，在访问不同的路由的时候，会发生两件事</li></ul><p>——- &gt;<br>HashHistory.push()将新的路由添加到浏览器访问的历史的栈顶，和hasHistory.replace()替换到当前栈顶路由</p><ul><li>history路由:<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &gt;<br>主要使用HTML5的pushState（）和replaceState（）这两个api结合window.popstate事件（监听浏览器前进后退）来实现的，pushState()可以改变<br>url地址且不会发送请求，replaceState()可以读取历史记录栈，还可以对浏览器记录进行修改</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>hash模式不美观，history模式较优雅</li><li>pushState设置的新URL可以与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL</li><li>pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中，而hash设置的新值与原来不一样才会触发记录添加到栈中</li><li>pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串</li><li>pushState可额外设置title属性供后续使用</li><li>hash兼容IE8以上，history兼容IE10以上</li><li>history模式需要后端配合将所有访问都指向index.html，否则用户刷新页面,会导致404错误</li></ol><p><strong>使用方法</strong></p><pre class="language-none"><code class="language-none">&lt; script &gt;  &#x2F;&#x2F; hash路由原理*************************** &#x2F;&#x2F; 监听hashchange方法 window.addEventListener(&#39;hashchange&#39;,()&#x3D;&gt;&#123; div.innerHTML&#x3D;location.hash.slice(1) &#125;) &#x2F;&#x2F; history路由原理************************ &#x2F;&#x2F; 利用html5的history的pushState方法结合window.popstate事件（监听浏览器前进后退） function routerChange (pathname)&#123; history.pushState(null,null,pathname) div.innerHTML&#x3D; location.pathname &#125; window.addEventListener(&#39;popstate&#39;,()&#x3D;&gt;&#123; div.innerHTML &#x3D; location.pathname &#125;) &lt;&#x2F;script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>new_Vue以后发生的事情</title>
      <link href="/2021/03/19/Vue/new-Vue%E4%BB%A5%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%E6%83%85/"/>
      <url>/2021/03/19/Vue/new-Vue%E4%BB%A5%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%E6%83%85/</url>
      
        <content type="html"><![CDATA[<h2 id="聊一聊new-Vue之后发生的事情"><a href="#聊一聊new-Vue之后发生的事情" class="headerlink" title="聊一聊new Vue之后发生的事情?"></a>聊一聊new Vue之后发生的事情?</h2><ol><li><p>new Vue会调用Vue原型链上的_init方法对Vue实例进行初始化;</p></li><li><p>首先是initLifecycle初始化生命周期,对Vue实例内部的一些属性(如 children、parent、isMounted)进行初始化；</p></li><li><p>initEvents，初始化当前实例上的一些自定义事件(Vue.$on);</p></li><li><p>initRender,解析slots绑定在Vue实例上，绑定createElement方法在实例上；</p></li><li><p>完成对生命周期、自定义事件等一系列属性的初始化后，触发生命周期钩子beforeCreate；</p></li><li><p>initInjections，在初始化data和props之前完成依赖注入（类似于React.Context）;</p></li><li><p>initState，完成对data和props的初始化，同时对属性完成数据劫持内部，启用监听者对数据进行监听（更改）;</p></li><li><p>initProvide，对依赖注入进行解析；</p></li><li><p>完成对数据（state状态）的初始化后，触发生命周期钩子created；</p></li><li><p>进入挂载阶段，将vue模板语法通过vue-loader解析生成虚拟dom数，虚拟dom树与数据完成双向绑定，触发生命周期钩子beforeMount；</p></li><li><p>将解析好的虚拟dom树通过vue渲染成真实DOM，触发生命周期钩子mounted；</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue首屏白屏怎么解决?</title>
      <link href="/2021/03/17/Vue/vue%E9%A6%96%E5%B1%8F%E7%99%BD%E5%B1%8F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3/"/>
      <url>/2021/03/17/Vue/vue%E9%A6%96%E5%B1%8F%E7%99%BD%E5%B1%8F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="vue首屏白屏怎么解决？"><a href="#vue首屏白屏怎么解决？" class="headerlink" title="vue首屏白屏怎么解决？"></a>vue首屏白屏怎么解决？</h2><ol><li><p>路由懒加载</p></li><li><p>vue-cli开启打包压缩 和后台配合gzip访问</p></li><li><p>进行cdn加速</p></li><li><p>开启vue服务器渲染模式</p></li><li><p>用webpack的externals属性把不需要打包的库文件分离出去，减少打包后的文件大小</p></li><li><p>在生产环境中删除不必要的console.log()</p></li></ol><pre class="language-none"><code class="language-none">plugins: [    new webpack.optimize.UglifyJsPlugin(&#123;    &#x2F;&#x2F;添加-删除     compress:&#123;     warnings:false,     drop_debugger:true,     drop_console:true        &#125;,     sourceMap:true    &#125;),</code></pre><p>开启nginx的gzip,在nginx.conf配置文件中配置</p><pre class="language-none"><code class="language-none">http &#123; &#x2F;&#x2F;在http中配置如下代码，    gzip on;    gzip_disable &quot;msie6&quot;;    gzip_vary on;    gzip_proxied any;    gzip_comp_level 8;        #压缩级别    gzip_buffers 16 8k;    #gzip_http_version 1.1;    gzip_min_length 100;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>json和xml数据的区别是什么？</title>
      <link href="/2020/06/28/javascript/json%E5%92%8Cxml%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2020/06/28/javascript/json%E5%92%8Cxml%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="json和xml数据的区别是什么"><a href="#json和xml数据的区别是什么" class="headerlink" title="json和xml数据的区别是什么?"></a>json和xml数据的区别是什么?</h2><ul><li>数据体积方面:<ul><li>xml是重量级的</li><li>json是轻量级的，传递的速度更快些。</li></ul></li><li>数据传输方面:<ul><li>xml在传输过程中比较占带宽</li><li>json占带宽少,易于压缩。</li></ul></li><li>数据交互方面:<ul><li>json于javascript的交互更加方便，更容易解析处理，更好的进行数据交互。</li><li>xml和json都用于项目交互下，xml多用于做配置文件，json用于数据交互。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React中的类组件和函数组件的区别</title>
      <link href="/2020/04/10/React/React%E4%B8%AD%E7%9A%84%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/04/10/React/React%E4%B8%AD%E7%9A%84%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="React中的类组件和函数组件之间有什么区别？"><a href="#React中的类组件和函数组件之间有什么区别？" class="headerlink" title="React中的类组件和函数组件之间有什么区别？"></a>React中的类组件和函数组件之间有什么区别？</h2><h3 id="类组件-class-components"><a href="#类组件-class-components" class="headerlink" title="类组件(class components)"></a>类组件(class components)</h3><ul><li><p>无论是使用函数或者类来声明一个组件，它绝不能修改组件的props。</p><ul><li>所有React组件都必须是纯函数，并禁止修改自身的props。</li></ul></li><li><p>React是单项数据流，父组件改变了属性，那么子组件视图会更新。</p><ul><li>属性props是外界传递过来的，状态state是组件本身的，状态可以在组件中任意修改</li><li>组件的属性和状态改变都会更新视图。</li></ul></li></ul><pre class="language-none"><code class="language-none">class Welcome extends React.Component &#123;        render() &#123;                return ( &lt; h1 &gt; Welcome &#123;                    this.props.name                &#125; &lt; &#x2F;h1&gt;);&#125;&#125;ReactDOM.render(&lt;Welcomename&#x3D;&#39;react&#39;&#x2F; &gt; , document.getElementById(&#39;root&#39;));</code></pre><h3 id="函数组件（functional-component）"><a href="#函数组件（functional-component）" class="headerlink" title="函数组件（functional component）"></a>函数组件（functional component）</h3><p>函数组件接受一个单一的props对象并返回了一个React元素</p><pre class="language-none"><code class="language-none">function Welcome(props) &#123;    return &lt;h1 &gt; Welcome &#123;        props.name    &#125; &lt; &#x2F;h1&gt;&#125;ReactDOM.render(&lt;Welcomename&#x3D;&#39;react&#39;&#x2F; &gt; , document.getElementById(&#39;root&#39;));</code></pre><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="语法上区别"><a href="#语法上区别" class="headerlink" title="语法上区别"></a>语法上区别</h3><p>两者最明显的不同就是在语法上，函数组件是一个纯函数，它接受一个props对象返回一个react元素。<br>而类组件需要继承React.Component并且创建render函数返回react元素,这将会要更多的代码，虽然它们实现的效果相同。</p><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>因为函数组件是一个纯函数，你不能在组件中使用setState()，这也是为什么把函数组件称作为无状态组件<br>如果你需要在你的组件中使用state，可以选择创建一个类组件或者将state提升到你的父组件中，然后通过props对象传递到子组件</p><h3 id="声明周期钩子"><a href="#声明周期钩子" class="headerlink" title="声明周期钩子"></a>声明周期钩子</h3><p>你不能再函数组件中使用声明周期钩子，原因和不能使用state一样，所有的生命周期钩子都来自于继承React.Component中<br>因此，如果你想使用声明周期钩子，那么需要使用类组件</p><p><strong>注意:</strong> 在react16.8版本添加了hooks，使得我们可以在函数组件中使用useState钩子去管理state，使用useEffect钩子去使用声明周期函数<br>因此，2,3两点不是他们的区别点，从这个改版中我们可以看出作者更看重函数组件，而且react团队曾提及到在react之后的版本将会对函数组件的性能方面进行提升</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>react组件通信方式</title>
      <link href="/2020/04/06/React/react%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/04/06/React/react%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="react组件通信的方式"><a href="#react组件通信的方式" class="headerlink" title="react组件通信的方式"></a>react组件通信的方式</h3><ul><li><p>父组件向子组件通讯：</p><ul><li>父组件可以向子组件通过传入props的方式，向子组件进行通讯</li></ul></li><li><p>子组件向父组件通讯:</p><ul><li>props + 回调的方式，父组件向子组件传递props进行通讯，此props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息作为参数，传递到父组件的作用域中</li></ul></li><li><p>兄弟组件通信:</p><ul><li>找到这两兄弟的节点共同的父节点，结合上面两种方式由父节点转发信息进行通讯</li></ul></li><li><p>跨层级通信:</p><ul><li>context设计的目的是为了共享那些对于一个组件树而言是’全局’的数据，例如当前认证的用户、主题或者首选语言，对于跨层的全局数据通过Context通信再合适不过</li></ul></li><li><p>发布订阅模式：</p><ul><li>发布者发布事件，订阅者监听事件并做出反应，我们可以通过引入event模块进行通讯</li></ul></li><li><p>全局状态管理工具:</p><ul><li>借助Redux或者Mobx等全局状态管理工具进行通信，这种工具会维护一个全局状态中心Store，并根据不同的事件产生新的状态</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redux原理</title>
      <link href="/2020/04/03/React/redux%E5%8E%9F%E7%90%86/"/>
      <url>/2020/04/03/React/redux%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="redux原理"><a href="#redux原理" class="headerlink" title="redux原理"></a>redux原理</h2><p>**Redux:**Redux是当今最热门的前端开发库之一.它是javascript程序的可预测状态容器，用于整个应用的状态管理.<br>使用Redux开发的应用易于测试，可以在不同的环境中运行，并显示一致的行为。</p><h3 id="数据如何通过Redux流动？"><a href="#数据如何通过Redux流动？" class="headerlink" title="数据如何通过Redux流动？"></a>数据如何通过Redux流动？</h3><ol><li>首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。</li><li>然后，Store自动调用Reducer，并且传入两个参数：当前State和Action，Reducer会返回新的State</li><li>State一旦发生变化，Store就会调用监听函数,来更新View。</li></ol><h3 id="Redux遵循的三个原则是什么？"><a href="#Redux遵循的三个原则是什么？" class="headerlink" title="Redux遵循的三个原则是什么？"></a>Redux遵循的三个原则是什么？</h3><ol><li>单一事实来源:整个应用的状态存储在单个store中的对象&#x2F;状态树里，单一状态树可以更容易地跟踪时间变化，并调试或检查应用程序.</li><li>状态是只读的:改变状态的唯一方法是触发一个动作。动作是描述变化的普通js对象，就像state是数据最小的表示一样，该操作是对数据更改的最小表示。</li><li>使用纯函数进行更改:为了指定状态树如果通过操作进行转化，你需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。</li></ol><p>你对”单一事实来源”有什么理解？<br>Redux使用”Store”将程序的整个状态存储在同一个地方。因此所有的组件状态都存储在Store中，并且它从Store本身接受更新.<br>单一状态树可以更容易地跟踪时间的变化，并调试或检查程序。</p><h3 id="Redux组成"><a href="#Redux组成" class="headerlink" title="Redux组成:"></a>Redux组成:</h3><ul><li>Action  用于描述发生了什么事情的对象</li><li>Reducer  这是一个确定状态将如何变化的地方</li><li>Store 整个程序的状态&#x2F;对象树保存在Store中</li><li>view 只显示Store提供的数据</li></ul><h3 id="如何在Redux中定义Action？"><a href="#如何在Redux中定义Action？" class="headerlink" title="如何在Redux中定义Action？"></a>如何在Redux中定义Action？</h3><p>react中的Action必须具有type属性，该属性指示正在执行的ACTION的类型。必须将他们定义为字符串常量，并且<br>还可以向其添加更多的属性。</p><p>redux中，Action被名为Action Creators的函数所创建,以下是Action和Action Creator的示例：</p><pre class="language-none"><code class="language-none">function addTodo（text）&#123;    return &#123;    type:ADD_TODO,    text        &#125;    &#125;</code></pre><p>解释Reducer的作用<br>Reducers是纯函数,它规定应用程序的状态怎样因响应ACTION而改变。reducers通过接受先前的状态和action来工作,<br>然后它返回一个新的状态。它根据操作的类型确定需要执行哪种更新，然后返回新的值，如果不需要完成任务，它会返回原来的状态。</p><h3 id="Store在Redux中的意义是什么？"><a href="#Store在Redux中的意义是什么？" class="headerlink" title="Store在Redux中的意义是什么？"></a>Store在Redux中的意义是什么？</h3><p>Store是一个javascript对象,它可以保存程序的状态，并提供一些方法来访问状态、调度操作和注册侦听器.应用程序的整个状态&#x2F;对象树保存在单一存储中。因此，<br>redux非常简单且是可预测的。我们可以将中间件传递到Store来处理数据,并记录改变存储状态的各种操作。所有操作都通过reducer返回一个新的状态。</p><h3 id="redux有哪些优点"><a href="#redux有哪些优点" class="headerlink" title="redux有哪些优点?"></a>redux有哪些优点?</h3><ul><li>结果的可预测性 - 由于总是存在一个真实来源，即store，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。</li><li>可维护性 - 代码变得更容易维护，具有可预测的结果和严格的结构。</li><li>服务器端渲染 - 你只需将服务器上创建的store传到客户端即可。这对初始化渲染非常有用，并且可以优化应用性能，从而提供更好的用户体验。</li><li>开发人员管理 - 从操作到状态更改，开发人员可以实时跟踪应用中发生的所有事情。</li><li>社区和生态系统 - Redux背后有一个巨大的社区，这使得它更加迷人。一个由才华横溢的人组成的大型社区为库的改进作出了贡献，并开发了各种应用。</li><li>易于测试 - Redux的代码主要是小巧，纯粹和独立的功能。这使代码可测试且独立。</li><li>组织 - Redux准确地说明了代码的组织方式，这使得代码在团队使用更加一致和简单。</li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js排序的几种方法</title>
      <link href="/2020/03/28/javascript/js%E6%8E%92%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2020/03/28/javascript/js%E6%8E%92%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>–</p><h3 id="js排序的几种方法"><a href="#js排序的几种方法" class="headerlink" title="js排序的几种方法"></a>js排序的几种方法</h3><ol><li><p><strong>sort（）排序</strong></p><pre class="language-none"><code class="language-none">var ar1&#x3D;[2,4,6,8,1,3]var ar2&#x3D;[2,16,36,8,56]ar1.sort()ar2.sort()    &#x2F;&#x2F;这个方法值只能排序第一位数  也可以字符串进行排序console.log(ar1)    &#x2F;&#x2F;[1,2,3,4,6,8]console.log(ar2)    &#x2F;&#x2F;[16, 2, 36, 56, 8]ar2.sort(function(a,b)&#123;    return a-b      &#x2F;&#x2F;a-b为升序    &#x2F;&#x2F;return b-a    &#x2F;&#x2F;b-a为降序&#125;)console.log(ar2)&#x2F;&#x2F;[2, 8, 16, 36, 56]</code></pre></li><li><p><strong>reverse()方法</strong></p><pre class="language-none"><code class="language-none">var ar1&#x3D;[2,4,6,8,1,3]ar1.reverse()       &#x2F;&#x2F;此方法为倒序，也就是反过来。并不会进行大小排序console.log(ar1)    &#x2F;&#x2F;[3, 1, 8, 6, 4, 2]</code></pre></li><li><p><strong>冒泡排序</strong></p><pre class="language-none"><code class="language-none">&#x2F;每轮依次比较相邻两个数的大小，后面比前面小则交换var b&#x3D;0&#x2F;&#x2F;设置用来调换位置的值var a&#x3D;[1,9,33,2,5,34,23,98,14]  &#x2F;&#x2F;冒泡排序for(var i&#x3D;0;i&lt;a.length;i++)&#123;    for(var j&#x3D;0;j&lt;a.length;j++)&#123;        if(a[j]&gt;a[j+1])&#123;            b&#x3D;a[j]            a[j]&#x3D;a[j+1]            a[j+1]&#x3D;b        &#125;    &#125;&#125;console.log(a)&#x2F;&#x2F;[1, 2, 5, 9, 14, 23, 33, 34, 98]</code></pre></li><li><p><strong>选择排序</strong></p><pre class="language-none"><code class="language-none">通过比较首先选出最小的数放在第一个位置上，然后在其余的数中选出次小数放在第二个位置上,依此类推,直到所有的数成为有序序列。var arr &#x3D; [9, 8, 7, 6, 5, 4];&#x2F;&#x2F;用选择排序的方法从小到大排列数组元素。&#x2F;&#x2F;比较的轮数for(var i &#x3D; 0; i &lt; arr.length - 1; i++)&#123;&#x2F;&#x2F;每轮比较的次数　　for(var j &#x3D; i + 1; j &lt; arr.length; j++)&#123;　　　　if(arr[i] &gt; arr[j])&#123;　　　　　　var tmp &#x3D; arr[i];　　　　　　arr[i] &#x3D; arr[j];　　　　　　arr[j] &#x3D; tmp;　　　　&#125;　　&#125;&#125;alert(arr);&#x2F;&#x2F;4,5,6,7,8,9</code></pre></li><li><p><strong>快速排序</strong><br>先从数列中取出一个数作为基准数<br>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边<br>再对左右区间重复第二步，直到各区间只有一个数</p><pre class="language-none"><code class="language-none">function quickSort(arr, i, j) &#123;  if(i &lt; j) &#123;    let left &#x3D; i;    let right &#x3D; j;    let mid &#x3D; Math.floor((left+right)&#x2F;2);    let temp &#x3D; arr[left];    arr[left] &#x3D; arr[mid];    arr[mid] &#x3D; temp;    let pivot &#x3D; arr[left];    while(i &lt; j) &#123;      while(arr[j] &gt;&#x3D; pivot &amp;&amp; i &lt; j) &#123;  &#x2F;&#x2F; 从后往前找比基准小的数        j--;      &#125;      if(i &lt; j) &#123;        arr[i++] &#x3D; arr[j];      &#125;      while(arr[i] &lt;&#x3D; pivot &amp;&amp; i &lt; j) &#123;  &#x2F;&#x2F; 从前往后找比基准大的数        i++;      &#125;      if(i &lt; j) &#123;        arr[j--] &#x3D; arr[i];      &#125;    &#125;    arr[i] &#x3D; pivot;    quickSort(arr, left, i-1);    quickSort(arr, i+1, right);    return arr;  &#125;&#125;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>This指向问题</title>
      <link href="/2020/02/05/javascript/This%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/"/>
      <url>/2020/02/05/javascript/This%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><strong>不同情况的调用，this指向分别如何。顺带可以提一下 es6 中箭头函数没有 this, arguments, super 等，这些只依赖包含箭头函数最接近的函数</strong></p><h3 id="函数执行改变this"><a href="#函数执行改变this" class="headerlink" title="函数执行改变this"></a>函数执行改变this</h3><p>由于 JS 的设计原理: 在函数中，可以引用运行环境中的变量。因此就需要一个机制来让我们可以在函数体内部获取当前的运行环境，这便是this</p><pre class="language-none"><code class="language-none">因此要明白 this 指向，其实就是要搞清楚 函数的运行环境，说人话就是，谁调用了函数。例如</code></pre><ul><li>obj.fn()，便是 obj 调用了函数，既函数中的 this &#x3D;&#x3D;&#x3D; obj</li><li>fn()，这里可以看成 window.fn()，因此 this &#x3D;&#x3D;&#x3D; window</li></ul><h3 id="但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改-this-的指向"><a href="#但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改-this-的指向" class="headerlink" title="但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改 this 的指向:"></a>但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改 this 的指向:</h3><ul><li>call: fn.call(target, 1, 2)</li><li>apply: fn.apply(target, [1, 2])</li><li>bind: fn.bind(target)(1,2)</li></ul><h3 id="apply-x2F-call-x2F-bind-原理"><a href="#apply-x2F-call-x2F-bind-原理" class="headerlink" title="apply&#x2F;call&#x2F;bind 原理"></a>apply&#x2F;call&#x2F;bind 原理</h3><p><img src="https://s.poetries.work/images/20210414155100.png"></p><p>all、apply 和 bind 是挂在 Function 对象上的三个方法，调用这三个方法的必须是一个函数</p><pre class="language-none"><code class="language-none">func.call(thisArg, param1, param2, ...)func.apply(thisArg, [param1,param2,...])func.bind(thisArg, param1, param2, ...)</code></pre><p>在浏览器里，在全局范围内this 指向window对象；<br>在函数中，this永远指向最后调用他的那个对象；<br>构造函数中，this指向new出来的那个新的对象；<br>apply、call、bind都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。</p><p><img src="https://s.poetries.work/gitee/2020/09/6.png"></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
