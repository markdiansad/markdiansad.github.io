<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>webpack5_Loader</title>
      <link href="/2022/04/21/webpack5-Loader/"/>
      <url>/2022/04/21/webpack5-Loader/</url>
      
        <content type="html"><![CDATA[<p>–</p><h1 id="webpack-Loader整理"><a href="#webpack-Loader整理" class="headerlink" title="webpack Loader整理"></a>webpack Loader整理</h1><h2 id="1-Loader机制的作用是什么？"><a href="#1-Loader机制的作用是什么？" class="headerlink" title="1. Loader机制的作用是什么？"></a>1. Loader机制的作用是什么？</h2><ul><li>webpack 本身只能处理 JavaScript 和 JSON 文件，而 loader 为 webpack 添加了处理其他类型文件的能力。</li><li>webpack默认只能打包js文件，配置里的module.rules数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换打包成js。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：use属性的值需要是一个由 Loader 名称组成的数组，Loader 的执行顺序是由后到前的；每一个 Loader 都可以通过 URL querystring 的方式传入参数，例如css-loader?minimize中的minimize告诉css-loader要开启 CSS 压缩。</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-有哪些常见的Loader？他们是解决什么问题的？"><a href="#2-有哪些常见的Loader？他们是解决什么问题的？" class="headerlink" title="2. 有哪些常见的Loader？他们是解决什么问题的？"></a>2. 有哪些常见的Loader？他们是解决什么问题的？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">● file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件</span><br><span class="line"></span><br><span class="line">● url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去</span><br><span class="line"></span><br><span class="line">● source-map-loader：加载额外的 Source Map 文件，以方便断点调试</span><br><span class="line"></span><br><span class="line">● image-loader：加载并且压缩图片文件</span><br><span class="line"></span><br><span class="line">● babel-loader：把 ES6 转换成 ES5</span><br><span class="line"></span><br><span class="line">● css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</span><br><span class="line"></span><br><span class="line">● style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。</span><br><span class="line"></span><br><span class="line">● eslint-loader：通过 ESLint 检查 JavaScript 代码</span><br></pre></td></tr></table></figure><h2 id="3-Webpack-的-Loader-是什么？"><a href="#3-Webpack-的-Loader-是什么？" class="headerlink" title="3. Webpack 的 Loader 是什么？"></a>3. Webpack 的 Loader 是什么？</h2><p>Webpack 只能理解 JavaScript 和 JSON 文件，这是 Webpack 开箱可用的自带能力。loader 可以让 Webpack 能够去处理其他类型的文件，chunk 文件以供应用程序使用，以及被添加到依赖图中，也可将内联图像转换为 data URL。简单来说，loader 可以将一段代码转换成另一端代码，通常用来将一段特殊代码转换成一段浏览器可识别的代码。</p><ul><li>loader 有两个属性：<ul><li>test，正则表达式，用于识别出哪些文件会被转换，</li><li>use 定义在进行转换时应该使用哪个<ul><li>loader，可以是字符串、数组和对象。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack5_Plugin</title>
      <link href="/2022/04/21/webpack5-Plugin/"/>
      <url>/2022/04/21/webpack5-Plugin/</url>
      
        <content type="html"><![CDATA[<p>–</p><h1 id="webpack-Plugin整理"><a href="#webpack-Plugin整理" class="headerlink" title="webpack Plugin整理"></a>webpack Plugin整理</h1><h2 id="1-Plugin（插件）的作用是什么？"><a href="#1-Plugin（插件）的作用是什么？" class="headerlink" title="1. Plugin（插件）的作用是什么？"></a>1. Plugin（插件）的作用是什么？</h2><p>通过安装和配置第三方的插件，可以拓展 webpack 的能力，从而让 webpack 用起来更方便。最常用的webpack 插件有如下两个：</p><ul><li><p>webpack-dev-server</p><ul><li>类似于 node.js 阶段用到的 nodemon 工具每当修改了源代码，webpack 会自动进行项目的打包和构建</li></ul></li><li><p>html-webpack-plugin</p><ul><li>webpack 中的 HTML 插件（类似于一个模板引擎插件）可以通过此插件自定制 index.html 页面的内容</li></ul></li></ul><p><strong>webpack-dev-server 可以让 webpack 监听项目源代码的变化，从而进行自动打包构建。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修改package.json -&gt; scripts中的dev命令：</span><br><span class="line"></span><br><span class="line">&quot;scripts&quot;:&#123;</span><br><span class="line">      &quot;dev&quot;：&quot;webpack serve&quot;，// script 节点下的脚本,可以通过 npm run 执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-有哪些常见的Plugin？他们是解决什么问题的？"><a href="#2-有哪些常见的Plugin？他们是解决什么问题的？" class="headerlink" title="2. 有哪些常见的Plugin？他们是解决什么问题的？"></a>2. 有哪些常见的Plugin？他们是解决什么问题的？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">● define-plugin：定义环境变量</span><br><span class="line"></span><br><span class="line">● commons-chunk-plugin：提取公共代码</span><br><span class="line"></span><br><span class="line">● uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码</span><br><span class="line"></span><br><span class="line">● purgecss-webpack-plugin：擦除无用css</span><br><span class="line"></span><br><span class="line">● happypack：多线程处理打包</span><br><span class="line"></span><br><span class="line">● webpack-bundle-analyzer：打包分析</span><br><span class="line"></span><br><span class="line">● speed-measure-webpack-plugin：构建速度分析</span><br><span class="line"></span><br><span class="line">● html-webpack-plugin：为html文件中引入的外部资源如script、link动态添加每次compile后的hash，防止引用缓存的外部文件问题</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-Webpack-的-Plugin-是什么？"><a href="#3-Webpack-的-Plugin-是什么？" class="headerlink" title="3. Webpack 的 Plugin 是什么？"></a>3. Webpack 的 Plugin 是什么？</h2><p>plugin是插件的意思，通常是用于对某个现有的架构进行扩展。<br>        &#x3D;&#x3D;&gt; webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等。</p><h2 id="4-Loader和Plugin的不同？"><a href="#4-Loader和Plugin的不同？" class="headerlink" title="4. Loader和Plugin的不同？"></a>4. Loader和Plugin的不同？</h2><h3 id="不同的作用"><a href="#不同的作用" class="headerlink" title="不同的作用"></a>不同的作用</h3><ul><li>Loader直译为”加载器”。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力</li><li>Plugin直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li></ul><h3 id="不同的用法"><a href="#不同的用法" class="headerlink" title="不同的用法"></a>不同的用法</h3><ul><li>Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）</li><li>Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。</li></ul><h3 id="4-描述一下编写loader或plugin的思路？"><a href="#4-描述一下编写loader或plugin的思路？" class="headerlink" title="4.描述一下编写loader或plugin的思路？"></a>4.描述一下编写loader或plugin的思路？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Loader像一个&quot;翻译官&quot;把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。</span><br><span class="line"></span><br><span class="line">编写Loader时要遵循单一原则，每个Loader只做一种&quot;转义&quot;工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。</span><br><span class="line"></span><br><span class="line">相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack整理</title>
      <link href="/2022/04/20/webpack5%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/04/20/webpack5%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>–</p><h1 id="webpack5概念"><a href="#webpack5概念" class="headerlink" title="webpack5概念"></a>webpack5概念</h1><h2 id="1-谈谈你对Webpack的理解？"><a href="#1-谈谈你对Webpack的理解？" class="headerlink" title="1.谈谈你对Webpack的理解？"></a>1.谈谈你对Webpack的理解？</h2><p>是一个模块化打包工具，将不同的资源和文件，进行打包，合并在一个文件里。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、依赖管理：方便引用第三方模块，让模块更容易复用、避免全局注入导致的冲突、、避免重复加载或者加载不必要的模块</span><br><span class="line">2、合并代码：把各个分散的模块集中打包成大文件，减少HTTP的链接的请求次数，配合uglify.js可以减少、优化代码的体积</span><br><span class="line">3、各种插件：babel把ES6+转[webpack5整理]()化为ES5-，eslint可以检查编译时的各种错误</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-webpack的工作原理"><a href="#2-webpack的工作原理" class="headerlink" title="2.webpack的工作原理?"></a>2.webpack的工作原理?</h2><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. Entry:入口指示webpack以哪个文件为入口起点开始打包，分析构建内部依赖图</span><br><span class="line"></span><br><span class="line">2. output:输出指示webpack的打包后的资源bundles输出到哪里去，以及如何命名</span><br><span class="line"></span><br><span class="line">3. Loader:让webpack能够去处理哪些非JavaScrip文件（webpack自身只理解javaScript)</span><br><span class="line"></span><br><span class="line">4. plugin:插件可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等</span><br><span class="line"></span><br><span class="line">5. mode:模式指示webpack使用相应模式的配置</span><br></pre></td></tr></table></figure><h4 id="流程概括"><a href="#流程概括" class="headerlink" title="流程概括"></a>流程概括</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</span><br><span class="line"></span><br><span class="line">1. 初始化参数：从配置文件和Shell语句中读取与合并参数，得出最终的参数；</span><br><span class="line"></span><br><span class="line">2. 开始编译： 用上一步得到的参数初始化Complier对象，加载所有配置的插件，执行对象的run方法开始执行编译；</span><br><span class="line"></span><br><span class="line">3. 确定入口： 根据配置中的entry找出所有入口文件；</span><br><span class="line"></span><br><span class="line">4. 编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理；</span><br><span class="line"></span><br><span class="line">5. 完成模块编译： 在经过第4步使用Loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及他们之间的依赖关系；</span><br><span class="line"></span><br><span class="line">6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</span><br><span class="line"></span><br><span class="line">7. 输出完成： 在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</span><br><span class="line">在以上过程中，webpack会在特定的时间点广播出特定的时间，插件在监听到感兴趣的时间后会执行特定的逻辑，并且插件可以调用Webpack提供的API改变Webpack的运行结果。</span><br></pre></td></tr></table></figure><h4 id="流程细节"><a href="#流程细节" class="headerlink" title="流程细节"></a>流程细节</h4><ul><li>Webpack的构建流程可以分为以下三个阶段：<ul><li><ol><li>初始化：启动构建，读取与合并配置参数，加载Plugin，实例化Complier.</li></ol></li><li><ol start="2"><li>编译：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件内容，再找到该Module依赖的Module，递归地进行编译处理。</li></ol></li><li><ol start="3"><li>输出： 对编译后的Module组合成Chunk，把Chunk转换成文件，输出到文件系统。</li></ol></li></ul></li></ul><h2 id="3-webpack4和webpack5的区别？"><a href="#3-webpack4和webpack5的区别？" class="headerlink" title="3.webpack4和webpack5的区别？"></a>3.webpack4和webpack5的区别？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">更快的构建速度</span><br><span class="line"></span><br><span class="line">更高的版本要求</span><br><span class="line"></span><br><span class="line">更灵活的模块组合</span><br><span class="line"></span><br><span class="line">更智能的缓存优化</span><br><span class="line"></span><br><span class="line">更小的体积</span><br><span class="line"></span><br><span class="line">webpack4 上需要下载安装 terser-webpack-plugin 插件</span><br><span class="line"></span><br><span class="line">webpack5 内部本身就自带 js 压缩功能，他内置了 terser-webpack-plugin 插件，我们不用再下载安装。而且在 mode=“production” 的时候会自动开启 js 压缩功能。</span><br><span class="line"></span><br><span class="line">webpack4 缓存配置</span><br><span class="line">    ==&gt; npm install hard-source-webpack-plugin -D</span><br><span class="line">    </span><br><span class="line">webpack5 缓存配置</span><br><span class="line">    ==&gt; webpack5 内部内置了 cache 缓存机制。直接配置即可。</span><br><span class="line">    ==&gt; cache 会在开发模式下被设置成 type： memory 而且会在生产模式把cache 给禁用掉。</span><br><span class="line"></span><br><span class="line">webpack4 启动服务</span><br><span class="line">    ==&gt; 通过 webpack-dev-server 启动服务</span><br><span class="line"> </span><br><span class="line">webpack5 启动服务</span><br><span class="line">    ==&gt; 内置使用 webpack serve 启动，但是他的日志不是很好，所以一般都加都喜欢用 webpack-dev-server 优化。</span><br><span class="line"></span><br><span class="line">打包的区别</span><br><span class="line">● webpack4打包:即使后续没有使用到num1的函数，依然会将代码打包进去</span><br><span class="line"></span><br><span class="line">● webpack5打包:后续没有使用到num1的函数，不会将代码打包进去</span><br><span class="line"></span><br><span class="line">输出代码的区别</span><br><span class="line">● webpack4只能输出es5的代码</span><br><span class="line">● webpack5新增属性output.ecmaVersion，可以生成ES5和ES6的代码</span><br></pre></td></tr></table></figure><h2 id="4-前端代码为何要进行构建和打包？"><a href="#4-前端代码为何要进行构建和打包？" class="headerlink" title="4. 前端代码为何要进行构建和打包？"></a>4. 前端代码为何要进行构建和打包？</h2><ul><li><p>代码方面体积更小，加载更快（tree-shaking，压缩合并）</p><ul><li>编译高级语言和语法（ts，es6，模块化）</li><li>兼容性和错误提示（polyfill，postcss，eslint）</li></ul></li><li><p>研发流程统一、高效的开发环境</p><ul><li>统一的构建流程和产出标准</li><li>集成公司构建规范（提测，上线）</li></ul></li></ul><h2 id="5-webpack的优缺点？"><a href="#5-webpack的优缺点？" class="headerlink" title="5. webpack的优缺点？"></a>5. webpack的优缺点？</h2><ol><li>优点<ul><li>webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD&#x2F;CMD 的支持也很全面，方便旧项目进行代码迁移。</li><li>能被模块化的不仅仅是 JS 了。</li><li>开发便捷，能替代部分 grunt&#x2F;gulp 的工作，比如打包、压缩混淆、图片转base64等。</li><li>扩展性强，插件机制完善</li></ul></li><li>缺点<ul><li>配置复杂</li><li>不分包bundle.js体积庞大</li><li>只能用于采用模块化开发的项目</li><li>打包慢</li><li>ES模块除Module外全用babel转换，但是一部分ES2015 语法的 firefox 与 chrome 浏览器中能直接跑的代码，无法用 webpack 编译</li></ul></li></ol><h2 id="6-什么是bundle，什么是chunk，什么是module"><a href="#6-什么是bundle，什么是chunk，什么是module" class="headerlink" title="6. 什么是bundle，什么是chunk，什么是module"></a>6. 什么是bundle，什么是chunk，什么是module</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bundle： 是由webpack打包出来的文件</span><br><span class="line"></span><br><span class="line">chunk： 是指webpack在进行模块依赖分析的时候，代码分割出来的代码块</span><br><span class="line"></span><br><span class="line">module： 是开发中的单个模块</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
